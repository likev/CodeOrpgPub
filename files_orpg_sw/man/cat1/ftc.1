ftc (1)                          ORPG Manpage                         ftc(1)

    
NAME
    ftc is a FORTRAN to c converter. For the moment, it is not a complete
    implementation. The conversion may need to be manually completed by a human
    programmer. ftc converts any to-be-converted FORTRAN line into a comment
    line with tag "TBD:". One must manually convert all such lines.
    
SYNOPSIS
    ftc [options] input_files
    
DESCRIPTION

    1. PARAMETER variables are converted to c macro constants (#define) and put
    in the task include file generated by ftc. We use all upper-case characters
    for naming such variables. If such a constant must be passed to a function
    by reference, an additional local variable (named with a trailing "_") is
    defined and initialized in the function. Only used macros are put in the
    task include file.

    In case macros defined by the FORTRAN PARAMETER variables are different
    from their definitions in the c global include files, we must use those
    from c files and not redefine them. We must also adjust the code
    accordingly when converting them to c. This can be specified in the "LIST
    of variable replacement:" section of ftc.conf. For example, VSDATOFF is
    defined in a309.h as "20" while it is defined in FORTRAN modules as "21".
    To let ftc to process this correctly, we must add line "VSDATOFF ->
    VSDATOFF + 1" in ftc.conf.

    COMMON variables are converted to global c structures named based on the
    COMMON block name. The first character of the name is upper-case while all
    other characters are lower-case. If the name is in section "WORDS not for
    variable names" in ftc.conf, the name is appended recursively with "_s"
    until it is no longer in the list. An additional field, if necessary, is
    added to the end of the structure to provide sufficient space for
    EQUIVALENCE variables. Unnamed common is not currently supported.

    Task level function names use lower-case characters except the first
    character which is upper-case. Proceeding module numbers are discarded. The
    names of library functions are not changed.

    All other variables are treated as local dynamic variables. Their names are
    all lower-case. One needs to manually identify those variables that must be
    static. ftc does not change variable dimensions except the CHARACTER type
    of variables. For example, a two-dimensional integer arrays in FORTRAN is
    always converted to a two-dimensional array in c. For CHARACTER variables,
    an additional dimension is added to implement the size of the type.

    FORTRAN CHARACTER type (string) is converted to char array in c. For
    examples, "CHARACTER*4 str" is converted char str[4]. "CHARACTER*4 strs[8]"
    is converted char strs[8][4]. Sub-string specifications are handled by ftc.

    2. String operators are converted to ftc internal function str_op which has
    the following interface:

        int str_op (char *func, char *arg1, int size1, char *arg2, int size2);

    where "func" is the operation to perform which can be one of "ASSIGN",
    "NE", "EQ", "GT", "LT", "GE", "LE", "LGT", "LLT", "LGE", "LLE" and "INDEX".
    "ASSIGN" is for operator "=". "NE" through "LE" are for string comparison
    operators. The remaining are for the corresponding intrinsic functions.
    "arg1" and "arg2" are the two string arguments and 'size1" and "size2" are
    the size of the two arguments.

    FORTRAN intrinsic functions are converted to c macros or functions. For
    examples, INT IFIX and IDINT are converted to macro F_INT. SQRT and DSQRT
    is converted to sqrt. The macros are defined in the task include file
    generated by ftc.

    3. All EQUIVALENCE statements for a routine are analyzed to find variable
    groups in each of which all variables are pointing to the same memory
    segment. In each group, one variable is selected to be the actual variable
    and all others are converted to appropriate pointers. The dimension of the
    actual variable may be extended to satisfy all other equivalent
    variables. If one of the variables is global (common), it is always
    selected as the actual variable. ftc generates appropriate code
    for initializing the pointers (casting). Unused variables are not shown up
    in the c code.

    4. ftc converts frequently used WRITE statement to c. A WRITE statement is
    converted to printf, if possible, or lprintf which is an ftc internal
    function. lprintf handles the non-null terminated FORTRAN character type.
    lprintf has the following interface:

        int lprintf (char *buf, int b_s, char *format, ...);

    where "buf" is the destination to write. In (int)buf < 256, it is
    considered as a "device" number. Otherwise it is treated as a pointer to a
    buffer to hold the output. If the device number is 6, it is considered as
    the standard output. "b_s" is the number of bytes to write to "buf". If
    "b_s" <= 0, it is ignored. "format" is the same as that for printf. The
    variable list then follows "format" similar to printf. For any character
    variable in the list, the number of bytes read from the variable is
    determined from "format". This implementation should be fine for most of
    cases. If we need to support the case where the string size is different
    from its format size, we can extend the function with additional arguments.

    Not all WRITE statements are converted. For example, WRITE with implied
    looping is not converted. The format conversion may not be completely
    implemented.

    Other input/output statements/functions are not converted for the moment.

    5. The DATA statement is not converted. All relevant DATA statements are
    presented as comments (with tag "TBD:") in the c file. One needs to convert
    them manually. If global variables are involved, one has to make sure each
    of the variables is initialized in only one of the c files.

    6. ftc supports function replacement. This is particularly useful for
    replacing FORTRAN library function calls with corresponding c library
    function calls. To provide function replacement info, one needs to prepare
    a section of "LIST of function replacement:" in ftc.conf. In the section,
    each line like the following specifies a function replacement:

        old_func_name -> new_func_name (exp1, exp2, ...)

    where "old_func_name" and "new_func_name" are respectively the function
    names to-be-replaced and to-be-replaced-by. "exp1", "exp2", ... are the
    arguments of "new_func_name". "exp?" are expressions which can contain $1,
    $2, ... which are the argument of "old_func_name".

    7. The comment lines are converted to c comment lines. Comment text are
    improved. Some comment lines are discarded (comment in include files,
    commented debugging statements and others).

    8. ftc (with -s option) searches all FORTRAN functions (task functions as
    well as library functions) to determine if any function parameter must be
    passed by reference. If a parameter does not need to be passed by
    reference, it is passed by value in the conversion. Any c library function
    that is called by these FORTRAN functions must also be scanned for this
    purpose. Refer to the EXAMPLE section later in this man-page.

    9. ftc generates a global include file for each task (executable program).
    The include file contains the following:

        Standard include files - e.g. #include <stdio.h>

        Constants definition - "#define"s converted from PARAMETERs.

        Global variable definition - Structures converted from COMMONs.

        Functions templates - All task functions are listed.

        ftc-defined code: Macros for FORTRAN intrinsic functions; ftc function
        templates; ftc function implementation (str_op and lprintf) which are
        compiled only for the c module that has main in it.

    The task include file is updated when a new .c file is generated for the
    task.

    10. Functions/subroutines from multiple FORTRAN files can be converted to a
    single c file. Each of the FORTRAN files can have multiple
    functions/subroutines. For example, "ftc -t prcpprod a31461.f a3148x.f"
    converts all functions/subroutines in the two .f files to a31461.f.c. Note
    that the first source file name is used for the output file name.

    In the converted c file, a module header, a RCS header and include
    statements for RPG include files are added. A function prologue is added
    for each function. The contents are extracted from the original FORTRAN
    prologue.

    11. Optionally one can use the ftc configuration file to provided
    additional info for customizing the conversion. The ftc configuration file
    must be names as "ftc.conf" and put in the current directory. Any line led
    by "#" is treated as a comment line (not used). The file contains sections,
    each of which starts with a section title line. An example of the title
    line is "LIST of function replacement:". Refer to elsewhere in this
    man-page for additional details on how to put specifications in the file.


OPTIONS

    "ftc" recognizes the following options:

    -p

        Post-processes the c file generated by f2c. The output is input_file.p
        where "input_file" is the name of the input file.

    -s file

        Searches for function templates from "input_file"(s) and adds them to
        "file". The input files can be of any of types .h, .c and .f. If "file"
        does not exist, it is created. If "file" does not have "." in its name,
        it is considered as a task name and file created is ftc_taskname.h.

    -t task_name

        Converts all routines in "input_file"(s) and puts them in first_name.c
        where "first_name" is the name of the first file in "input_file"(s).
        "task_name" specifies the task name. The default is "task". The task
        include file generated is "task_name.h". If "task_name.h" exists, the
        info is added to it.

    -h

        Prints usage info and terminates.

EXAMPLES

    1. We create template file "ftc_rpg_glob.h" by scanning several c include
    file which contains the templates of functions that are to be called by our
    FORTRAN routines (task routines as well as dependent library routines):

        rm ftc_rpg_glob.h
        ftc -s ftc_rpg_glob.h /import/builds_cmlnxsvr/linux12/lib/include/rpg.h /import/builds_cmlnxsvr/linux12/lib/include/rpg_globals.h

    2. We scan FORTRAN library (common) files, ftc_rpg_glob.h lib001/*.f and
    ftc_rpg_glob.h lib002/*.f, to retrieve function templates and add them to
    "ftc_rpg_glob.h":

        ftc -s ftc_rpg_glob.h lib001/*.f ftc_rpg_glob.h lib002/*.f

    Note that these *.f file were read from
    /import/builds_cmlnxsvr/linux12/src/cpc101, pre-processed by ftnpp and
    saved in ./lib001 and ./lib002 using, for example, the procedure:

        mkdir lib001 lib002
        cd lib001
        cp $xpit/src/cpc101/lib001/*.ftn .
        ftnpp -a -DLINUX -DLITTLE_ENDIAN -DLITTLE_ENDIAN_MACHINE  -r INT2=int -r BTEST=os32btest -r ENVIRON=RPGENVIRON -I. -I$xpit/include -I$xpit/lib/include *.ftn
        cd lib002
        cp $xpit/src/cpc101/lib002/*.ftn .
        ftnpp -a -DLINUX -DLITTLE_ENDIAN -DLITTLE_ENDIAN_MACHINE  -r INT2=int -r BTEST=os32btest -r ENVIRON=RPGENVIRON -I. -I$xpit/include -I$xpit/lib/include *.ftn

    A slightly modified version of ftnpp must be used here.

    ftc_rpg_glob.h generated here can be used for all RPG tasks. It needs to
    be regenerated only if the template of any of the library routines changes.

    3. To convert one FORTRAN task, e.g. prcpprod, we do the following.

        a. In a working directory, we copy all FORTRAN files to the directory.
        We convert them to *.f files using ftnpp. We copy ftc_rpg_glob.h to the
        directory. The *.ftn file will no longer needed.

        b. We create a function template file for the task, e.g. named 
        prcpprod:

        rm ftc_prcpprod.h
        ftc -s prcpprod ftc_rpg_glob.h *.f

        Note that a task's function template file is always names by
    ftc_taskname. ftc_prcpprod.h needs to be generated only once. If however
    any of the task functions interface changes, it must be regenerated.

        c. We convert the task's FORTRAN files to c files. For example, assume
    we have 3 FORTRAN files, f1.f, f2.f and f3.f. We want to convert them and
    put functions in f1.f and f2.f in one c file and those in f3.f in another
    file. we do the following:

        rm prcpprod.h
        ftc -t prcpprod f1.f f2.f
        ftc -t prcpprod f3.f

        Note that each "ftc -t taskname" call generates a c file named name.c
    where "name" is the name of the first file in the list. The above two
    commands generate f1.f.c and f3.f.c. The first call generate file
    "prcpprod.h" and subsequent calls update it.

        The c files generate should be reviewed. Any comment with tag "TBD:"
    must be manually converted. Then the files are ready for being compiled.
    The compiling may fail because of something not prompted converted. Manual
    fixes then is required.

SEE ALSO
    f2c
