
NAME
    Miscellaneous utility functions.

SYNOPSIS

    #include <infr.h> or #include <misc.h>

    Byte swapping function: 

	SHORT_BSWAP (short a);

	INT_BSWAP (int a);

	INT_SSWAP (int a);

	int MISC_bswap (int swap_size, void *in_buf, 
					int n_items, void *out_buf);
	
	void MISC_swap_shorts (int no_of_shorts, short* buf);
	
	void MISC_swap_longs (int no_of_longs, long* longs);
	
	void MISC_swap_floats (int no_of_floats, float* buf);

    Platform-independent signal functions: 

	int MISC_sig_raise (int sig);
	
	void (*MISC_sig_signal (int signo, void (*disp)(int)))(int);
	
	void (*MISC_sig_sigset (int signo, void (*disp)(int)))(int);
	
	int MISC_sig_sighold (int signo);
	
	int MISC_sig_sigpause (int signo);
	
	int MISC_sig_sigrelse (int signo);

    Variable-size table function: 

	void *MISC_create_table (int entry_size, int inc);
	
	void *MISC_open_table (int entry_size, int inc, 
			int keep_order, int *n_ent_pt, char **tbl_pt);

	void MISC_free_table (void *tblpt);
	
	void *MISC_get_table (void *tblpt, int *size);
	
	void *MISC_table_new_entry (void *tblpt, int *ind);
	
	void MISC_table_free_entry (void *tblpt, int ind);

	int MISC_table_search (void *tblpt, void *ent, 
			int (*cmp) (void *, void *), int *ind);

	int MISC_table_insert (void *tblpt, void *ent, 
					int (*cmp) (void *, void *));

    Process spawning functions: 

	int MISC_system_to_buffer (char *cmd, char *obuf, 
					int bsize, int *n_bytes);

	void MISC_system_shell (char *shell_cmd);
	void MISC_system_setsid (int yes);

    Co-process functions:

	void MISC_cp_close (void *cp);

	int MISC_cp_read_from_cp (void *cp, char *buf, int b_size);

	int MISC_cp_write_to_cp (void *cp, char *str);

	int MISC_cp_open (char *cmd, int flag, void **rcp);

	int MISC_cp_get_status (void *cp);

    Interrupt-insensitive functions: 

	int MISC_write (int fd, const char *buf, int wlen);

	int MISC_read (int fd, char *buf, int rlen);

	int MISC_close (int fd);

	int MISC_open (const char *path, int oflag, mode_t mode);

	int MISC_unlink (const char *path);

	int MISC_stat (const char *path, struct stat *buf);

	int MISC_fstat (int fd, struct stat *buf);

	int MISC_system (const char *string);

	FILE *MISC_fopen (const char *filename, const char *mode);

	int MISC_fclose (FILE *stream);

    The RSIS function:

	int RSIS_size (int maxn, int n_keys, int rec_size);
	
	char *RSIS_init (int maxn, int n_keys, int rec_size, 
						char *buf, int (*compare)());

	int RSIS_insert (char *rsid, void *new_rec);
	
	int RSIS_delete (char *rsid, int ind);
	
	int RSIS_find (char *rsid, int which_key, void *key, void *record);
	
	int RSIS_traverse (char *rsid, int which_key, int dir, int ind, 
							void *record);
	
	int RSIS_left (char *rsid, void *record);
	
	int RSIS_right (char *rsid, void *record);
	
	char *RSIS_localize (char *buf, int (*compare)());
	
	int RSIS_get_next_ind (char *rsid, int ind);
	
	char *RSIS_get_record_address (char *rsid);

    Application directories: 

	int MISC_get_work_dir (char *buf, int buf_size);
	
	int MISC_get_cfg_dir (char *buf, int buf_size);
	
	int MISC_get_log_dir (char *buf, int buf_size);

	int MISC_mkdir (char *path);

	int MISC_get_tmp_path (char *buf, int buf_size);

    String utilities: 
	
	char *MISC_basename (char *path);

	char *MISC_full_path (char *dir, char *fname, char *buf, int buf_size);
 	
	char *MISC_dirname (char *path, char *buf, int buf_size);

	void MISC_string_fit (char *trgt_string, size_t trgt_string_size, 
			int fit_flag, char fit_char, const char *src_string);
		
	char *MISC_tolower (char *str);

	char *MISC_toupper (char *str);

	int MISC_get_token (char *str, char *format, 
						int ind, void *buf, int b_s);

	int MISC_char_cnt (char *str, char *c_set);

	void MISC_string_date_time (char *date_time,
                      		int date_time_size, const time_t *intime);

	char *MISC_expand_env (const char *str, char *buf, int buf_size);

    Log functions: 

	void MISC_log (const char *format, ...);

	void MISC_log_reg_callback (void (*log_cb)(char *));

	void MISC_log_disable (int disable);

    Memory allocation functions:

	void *MISC_malloc (size_t size);

	void MISC_malloc_retry (int yes);

    Binary search: 

	int MISC_bsearch (void *ent, void *tbl, int tbl_size, int item_size, 
				int (*cmp) (void *, void *), int *ind);

    Utility functions: 

	ALIGNED_SIZE (int size);

	ALIGNED_T_SIZE (int size);

	int unix_time (time_t *time, int *y, int *mon, 
					int *d, int *h, int *m, int *s);
	
	int msleep (int ms);

	time_t MISC_systime (int *ms);

    Stack printing: 

	void MISC_proc_printstack (int pid, int out_buf_size, char *out_buf);

    Dynamic function loading:

	void *MISC_get_func (char *lib, char *func, int quiet);

    OS resource functions: 

	int MISC_rsrc_nofile(int nofile);

    Data Compression functions:

	int MISC_decompress (int method, char *src, int src_len,
					char *dest, int dest_len);

	int MISC_compress (int method, char *src, int src_len,
					char *dest, int dest_len);
	


DESCRIPTION
    The MISC module is a collection of miscellaneous utility functions. Other 
    libinfr modules may depend on this module. See misc.h for error return 
    values.

    ALIGNED_SIZE is a macro that returns the machine dependent aligned size of
    argument "size". If, for example, the aligned size is 4 and "size" = 2,
    ALIGNED_SIZE will return 4. We use this macro, for example, when we have to
    put several structures in a given message and we want them all to be
    aligned so that we can cast the address of the entire message to a pointer.

    ALIGNED_T_SIZE is similar to ALIGNED_SIZE except that it returns the
    aligned size in unit of aligned size. e.g. If the aligned size is 4 and
    "size" = 2, ALIGNED_T_SIZE will return 1.

    unix_time converts the UNIX time in "time", if it is non-zero, to year,
    month, day, hour, minute and second returned in arguments "y", "mon", "d",
    "h", "m" and "s". If "time" is assigned with value zero before this
    function is called, it converts the values in "y", "mon", "d", "h", "m" and
    "s" to the UNIX time and returns it in "time". The UNIX time is the number
    of seconds from 00:00:00, 01/01/1970, GMT. The argument "y" must be at
    least 1970. "mon" is in the range of 1 through 12. "d" starts from 1. "h"
    is in the range of 0 through 23. "m" and "s" are in the range of 0 through
    59.

    unix_time returns 0 on success or -1 on failure (when an argument is
    detected to be out of range).

    This function uses unsigned int internally. It works up to at least the end
    of year 2104 on 32 bit machines. This function is implemented by using an
    algorithm which is efficient in both memory and CPU usages.

    msleep puts the calling task in sleep (suspended) mode for "ms" milli-
    seconds. It calls the "select" system call to perform the task. Thus it
    does not use a timer. It may return before the scheduled time due to a
    signal. msleep returns 0, which is not useful.

    Because the select system call is not portable, a portable application
    should use this function for sleep. This function is different from the C
    "sleep" function, which typically uses the UNIX timer and thus can cause
    conflict if the application also uses the timer.

    MISC_systime returns the current system time in seconds. The time is 
    independent of date and time setting. The return value of the first call
    of this is the machine's clock time. This function must be called once in 
    no less than 6 months to maintain consistent results. If "ms" is not NULL,
    the milli-second value is returned with it.


    SHORT_BSWAP, a macro, swaps in-place the two bytes in short "a".

    INT_BSWAP, a macro, swaps in-place the four bytes in int "a".

    INT_SSWAP, a macro, swaps in-place the two shorts in int "a".

    MISC_bswap performs byte swap of an array of "n_item" elements if the local
    machine is of little endian. The size of each element is "swap_size" bytes,
    which must be 2, 4, or 8. The output buffer "out_buf" can overlap with or
    identical to the input array "in_buf".

    MISC_bswap returns the number of items processed (n_items) on success or -1
    on failure (when one of the argument is bad).

    MISC_swap_shorts swaps "no_of_shorts" data values in "buf". No copy is
    made, the short data values in the buffer are simply swapped.

    MISC_swap_longs swaps "no_of_longs" data values in "buf". No copy is made,
    the long data values in the buffer are simply swapped.

    MISC_swap_floats swaps "no_of_floats" data values in "buf". No copy is
    made, the float data values in the buffer are simply swapped.

    MISC_get_func dynamically loads function named "func" in shared library 
    file "lib". If "lib" is NULL or an empty string, the function is searched 
    in the libraries that are already loaded. If "quiet" is non-zero, no error
    is reported through MISC_log. It returns the function pointer on success or
    NULL on failure.

    MISC_rsrc_nofile can be used to get/set the resource limit on the number of
    file descriptors that a process may create.

    If the value of "nofile" is LESS THAN OR EQUAL TO THE CURRENT RESOURCE
    LIMIT, this routine will simply get the resource limit and return it as the
    return value. That is, the current resource limit can be retrieved by
    specifying a negative or zero value for "nofile".

    If the value of "nofile" is GREATER THAN THE CURRENT RESOURCE LIMIT, this
    routine will set the resource limit and return the new resource limit as
    the return value.

    MISC_rsrc_nofile returns the (positive) resource limit on success;
    otherwise, one of the following negative values on failure:

	MISC_RSRC_GET_ERR - error while getting the resource limit
	MISC_RSRC_SET_ERR - error while setting the resource limit


    MISC_get_work_dir returns, in "buf" of maximum length of "buf_size" bytes,
    the project work directory, which is defined as follows. If environmental
    variable "WORK_DIR" is defined, its value is used as the work directory
    path. Otherwise, $HOME/tmp is considered as the work directory. The
    environmantal variables WORK_DIR and HOME can be specified either with a
    trailing "/" or without it. MISC_get_work_dir creates the directory if it
    does not exist. The returned path is always NULL terminated and without
    trailing "/".

    MISC_get_cfg_dir, in a similar fashion to MISC_get_work_dir, returns the
    project configuration directory, which is defined by environmental variable
    "CFG_DIR". If "CFG_DIR" is not defined, it returns
    MISC_RSRC_ENVS_UNDEFINED.

    MISC_get_log_dir, in a similar fashion to MISC_get_work_dir, returns the
    project log directory, which is defined by environmental variable
    "LE_DIR_EVENT". If "LE_DIR_EVENT" is not defined, or is improperly defined
    (i.e., does not include directory pathname and event code number separated
    by a colon) it returns MISC_RSRC_ENVS_UNDEFINED.

    MISC_get_tmp_path returns a unique path for temporary directory or file 
    name in "buf" of size "buf_size". The return value is the size of the path
    on success or a negative error code on failure.

    On success, MISC_get_work_dir, MISC_get_cfg_dir, MISC_get_log_dir and
    MISC_get_tmp_path return the length of the corresponding directory path. On
    failure they return a negative error code.

    MISC_mkdir creates the directory "path" if it does not already exist. This 
    function calls "mkdir" recursively, if necessary, to create "path". 
    MISC_mkdir returns 0 on success or -1 on failure.


    Application software processes should use these functions rather than
    the Standard C signal() function or the Solaris simplified signal
    management functions.  These functions are built atop the POSIX signal
    mechanism.

    If the compile-time environment provides the corresponding simplified
    signal management routines, those routines are compiled-in.  Otherwise,
    function-replacement code is compiled.  For example, under SUNOS, the
    Solaris simplified signal management routines are called.  Under LINUX,
    for example, the replacement code is executed.


    MISC_sig_raise returns zero on success and -1 on failure. If an error
    occurs, a code is stored in errno to identify the error (EINVAL, EPERM,
    ESRCH). Application software processes should use MISC_sig_raise rather
    than the Standard C raise() function. This function is built atop the
    (superior) POSIX signal mechanism. Refer to the raise() manpage.

    MISC_sig_signal() and MISC_sig_sigset() alter the disposition of the
    specified signal.  The signal is specified by the "signo" argument.
    "signo" values of SIGKILL and SIGSTOP are not valid.  The disposition
    of the signal is specified by the "disp" argument.  "disp" may be the
    address of a signal handler or either SIG_DFL or SIG_IGN.  For
    MISC_sig_signal(), if "disp" is the address of a signal handler and
    "signo" is NOT SIGILL, SIGTRAP, or SIGPWR, the signal's disposition
    will be set to SIG_DFL before the signal handler is executed.  For
    MISC_sig_sigset(), if "disp" is the address of a signal handler,
    "signo" will be added to the signal mask of the calling process before
    the signal handler is executed; upon returning from the signal handler,
    the signal mask of the calling process will be reset to its state
    prior to delivery of the signal.  Also for MISC_sig_sigset(), if "disp"
    is SIG_HOLD, "signo" will be added to the signal mask of the calling
    process and the disposition of the signal will not be affected.

    MISC_sig_sighold() adds "signo" to the signal mask of the calling process.
    This is a front-end to the POSIX sigprocmask() function.

    MISC_sig_sigrelse() removes "signo" from the signal mask of the calling
    process.  This is a front-end to the POSIX sigprocmask() function.

    MISC_sig_sigpause() removes "signo" from the signal mask of the calling
    process and suspends the calling process until receipt of a signal.  This
    is basically a wrapper for the POSIX sigsuspend() function.

    MISC_sig_signal returns signal's previous disposition upon success;
    otherwise SIG_ERR is returned and the errno indicates the error.

    MISC_sig_sigset returns SIG_HOLD (if the signal had been blocked) or
    signal's previous disposition (if signal had not been blocked) upon
    success; otherwise SIG_ERR is returned and the errno indicates the error.

    MISC_sig_sighold returns 0 on success; otherwise -1 and errno set.

    MISC_sig_sigrelse returns 0 on success; otherwise -1 and errno set.

    MISC_sig_sigpause returns 0 on success; otherwise -1 and errno set.

    Use MISC_sig_sighold() and MISC_sig_sigrelse() or MISC_sig_sigpause()
    to control access to critical regions of code (i.e., defer delivery
    of given signal).

    MISC_basename takes the pathname pointed to by "path" and returns a pointer
    to the final component of the pathname. The returned pointer is read-only.
    If "path" is a null pointer or points to an empty string, this function
    returns a pointer to the string "". If "path" includes one or more trailing
    '/' characters, this function returns a pointer to the string "".
    MISC_basename will not modify the string pointed to by "path".

    MISC_full_path creates the full path from file name "file" and directory
    "dir" and puts the result in "buf" of size "buf_size". Return pointer "buf"
    on success or NULL on failure. Note that dir "" is the same as "/". The 
    current dir is "." or "./".

    MISC_dirname returns the directory part of path "path". "buf" of size
    "buf_size" is used to hold the result. The directory part does not include
    a trailing '/'. For example, if "path" is "/", it returns "". Multiple
    trailing '/' are removed. If the path has a '/' but the first char is not
    '/', nothing is added in the front. If "path" does not contain a '/', then
    this function returns a pointer to the string ".". If "path" is a null
    pointer or points to an empty string, this function returns a pointer to
    the string ".". MISC_dirname will not modify the string pointed to by
    "path". If "buf" is too small to hold the dir, the output is truncated.

    MISC_string_fit fits a (null-terminated) source string ("src_string") into
    a target string ("trgt_string") of specified size ("trgt_string_size",
    which includes space for terminating null). The source and target strings
    must not overlap in memory.

    The specified "fit_char" is used to indicate replacement of one or more
    characters. No characters are replaced if the target string is large enough
    to hold the source string without replacement. The manner in which the
    source string is "fit" into the target string is determined by the
    "fit_flag":

	MISC_STRING_FIT_FRONT - replace characters at front of string
	MISC_STRING_FIT_MIDDLE - replace characters in middle of string
	MISC_STRING_FIT_TRUNC - replace chars at end of string (truncate)

    If the specified "fit_char" is unprintable, a default character
    (MISC_STRING_FIT_DFLT_FIT_CHAR) will be used instead. If the specified
    "fit_flag" does not match one of those listed above, the source string will
    be truncated (if necessary).

    EXAMPLES: The source string "ima_long_string" will be "fit" into a
    11-character long string (excluding null) as follows (assumes that '*' is
    the "fit_char"):

	MISC_STRING_FIT_FRONT:	*ong_string
	MISC_STRING_FIT_MIDDLE:	ima_l*tring
	MISC_STRING_FIT_TRUNC:	ima_long_s*

    For example, "osrpg001" is the simple name that corresponds to the fully
    qualified domain name "osrpg001.nssl.noaa.gov".

    The returned pointer oints to static memory that may be modified during
    subsequent calls to this routine.

    EXAMPLES: The following illustrates some of the "simple name" return
    values:

	hostname			simple name
	--------			-----------
	NULL pointer			""
	""				""
	"."				""
	"osrpg001.nssl.noaa.gov"	"osrpg001"
	".nssl.noaa.gov"		""

    MISC_tolower converts all characters in null-terminated string "str" to 
    lower case. MISC_toupper converts all characters in null-terminated string
    "str" to upper case.

    MISC_get_token searches for the "ind"-th (0, 1, ...) token in string "str".
    "format" defines a separator (led with S), a quotation char (led with Q)
    and a conversion char (led with C). The default for them are respectively
    space, no quotation and no conversion. An example of "format" is "S\tQ\"",
    where the separator is '\t' and the quotation char is ". The token is
    separated by the separator and can be empty. '\t' can be the separator. If
    '\t' is not the separator, it is treated as a space. '\n' can be a
    separator. If the separator is not '\n', token finding ends with line
    return. Spaces and tabs adjacent a separator are discarded.

    The token is returned in caller-provided buffer "buf" of size "b_s". If the
    token is not found, buf is set to the empty string. This function returns
    the offset to the end of this token (e.g. str + ret is the pointer to the
    next token), 0 if the token is not found or a negative error code on
    failure. If buf is NULL, the total number of tokens is returned. 

    The accepted conversions are "c" for character string (the default), "i"
    for integer, "u" for unsigned integer, "f" for float, "d" for double, and
    "x" for hexadecimal (unsigned int). When a conversion other than "c" is
    specified, the token string is converted to the specified data type in the
    machine format. In this case, "buf" must be a pointer to the appropriate
    type. "b_s" is not used in this case.

    The quotation char is used for tokens with spaces or empty token. A
    quotation must be wrapped with two quotation chars. Any character except
    "\0" or "\n" inside a quotation is treated as part of the token.
    Specifically a separator inside quotation is not treated as separator. If a
    non-empty token is found after the last separator, it is considered as the
    last token. If no significant character is found after the last separator,
    we assume there is no token (not even an empty token).

    The following code, for example. processes each line in "text",

	p = text;
	while ((off = MISC_get_token (p, "S\n", 0, buf, b_size)) > 0) {
	    ...process line in buf
	    p += off;
	}

    MISC_char_cnt returns the count of chars in "str" until a char is not in
    the set of "c_set". If the first char in c_set is '\0', we look for the
    count of chars that are not in the set of "c_set" excluding the first char.

    MISC_string_date_time converts time "intime" to ASCII form and outputs it 
    in buffer "date_time" of size "date_time_size".

    MISC_expand_env expands all environmental variables, in the format of
    $(env_var_name), in "str" to their local values. The result is put in "buf"
    of size "buf_size". If a syntax error is found in "str", or "buf_size" is
    too small for the expended string, it returns "str" and buf is set to an
    empty string if "buf_size" is not 0. A message is logged. If an
    environmental variable if not defined, it is not expanded. The value of an
    environmental variable can have another environmental variable. Nested
    environmental variable, such as $(env$(env2)2), is allowed. Note that
    this function can be used simply to return the value of an environmental
    variable.

    MISC_open_table, MISC_free_table, MISC_get_table, MISC_table_new_entry and
    MISC_table_free_entry, MISC_table_search and MISC_table_insert implement 
    a simple variable size table manager.
    MISC_open_table must be called first to start a new table. It returns a
    pointer to be used later as an identifier for accessing the table. The
    table entry size in number of bytes is specified by "entry_size". The
    caller also specifies a buffer increment size in number of entries by
    "inc". The intial table buffer size will be "inc" entries. The buffer will
    then later be adjusted in incremant of "inc" entries. This avoids frequent
    malloc/free. "keep_order" is a boolean that specifies whether or not entry
    order must be preserved after deletion. The deletion will be more efficient
    if the order needs not to be preserved. One can also register, through
    "n_ent_pt" and "tbl_pt", the addresses of two user variables for receiving
    the number of entries and the pointer to the table. Note that these two
    values may change after inserting or deleting an entry. By registering
    these two addresses, one does need to call MISC_get_table to get the info.
    The two variables, if registered in MISC_open_table, must be valid with the
    scope where table manager function are to be used.

    MISC_create_table exists for backward compatibility. It calls
    MISC_open_table (entry_size, inc, 1, NULL, NULL).

    MISC_free_table frees all memory segments allocated for "tblpt". The table
    is not accessable after being freed.

    MISC_get_table returns the pointer to the first entry of the table. "tblpt"
    is the table identifier returned by MISC_create_table and "size" returns
    the table size. "size" will return 0 if "tblpt" is not initialized (NULL).

    MISC_table_new_entry returns the pointer to a new free entry and "ind", if
    not NULL, returns the index of the new entry in the table. The new entry is
    always at the end of the table.

    MISC_table_free_entry frees the "ind"-th entry in the table. It keeps the
    original entry order if the table is opened as "keep_order" type.
    MISC_table_free_entry will not alter any entries above the entry to be
    deleted. Thus, for example, one can do the following to remove all
    selected entries:

	my_structure *t;
	static char *table;
	static int tsize;

	MISC_open_table (entry_size, inc, keep_order, &tsize, &table);
	... Insert some entries ...

	for (i = 0; i < tsize; i++) {
	    if (select (table[i])) {
		MISC_table_free_entry (tbl, i);
		i--;
	    }
	}

    Note that after caling MISC_table_free_entry, variables tsize and table may
    change. If we were not registering them, we would have to call
    MISC_get_table after MISC_table_free_entry.

    MISC_table_search searches for an entry in the table "tblpt" that equals 
    (in terms of "cmp") "ent". If found, returns 1 and "ind" set to the first 
    found entry. Otherwise, returns 0 and "ind" set to the first entry that
    is greater than "ent". It returns 0 if the table is empty. The table must 
    be in non-decreasing order.

    MISC_table_insert inserts an entry "ent" in the table "tblpt" that keeps
    the table in non-decreasing order (in terms of "cmp"). Returns the index of
    the new entry on success or -1 if malloc failed.

    The comparison function used in MISC_table_search and MISC_table_insert has
    the following interface

	int (*cmp) (void *a1, void *a2).

    It must return 1, 0 or -1 respectively if a1 > a2, a1 = a2 or a1 < a2.

    This table manager is efficient for applications where frequent table
    look-up is required while adding/freeing entries are relatively infrequent.
    The first three function returns NULL on failures such as calling argument
    error and malloc error. The table manager may allocate new memory area for
    the table. Thus, after MISC_table_new_entry or MISC_table_free_entry call,
    one must call MISC_get_table to get the new table pointer.


    MISC_proc_printstack retrieves stack info of process "pid" and returns it
    with "out_buf" of size "out_buf_size". If "out_buf_size" <= 0, the stack
    info is printed to the stderr port. In cases of error conditions, an error
    message is put in "out_buf". If the buffer size is not sufficient, the data
    is truncated and null terminated. We invoke command "pstack" to get the
    stack info. This works for both SunOs and Linux. "pstack" must be installed
    and in the user's search path. Functions on the stack below 
    MISC_proc_printstack are discarded.


    RSIS_init initializes the data structures for the RSIS service for a new
    record set. The user record size is "record_size" and "n_keys" is the
    number of search keys. "buf" points to an buffer area used by RSIS and
    "maxn" is the maximum number of records to be stored. If "buf" is NULL,
    RSIS will allocate memory for the index service. "compare" is a user
    supplied comparing function:

	int compare (int which_key, void *r1, void *r2);

    Which returns RSIS_LESS, RSIS_EQUAL or RSIS_GREATER if the value of the
    key, specified by "which_key", of user record "r1" is less than, equal to
    or greater than that of user record "r2". "which_key" is an index
    (enumeration, must be contiguous and starts with 0) to the defined keys.
    E.g, if there are in total 3 keys, they are indexed by 0, 1, and 2. By
    using an user defined comparison function, the keys can be of any types
    (integer, floating point number, character string and so on). Any of the
    fields in the user record can be used as the keys. A key can also be any
    function of the record and thus does not need to be a field in the record.

    The RSIS routines store a number of user records and build indices for
    specified fields in the records for efficient searching by any of those
    field values (keys). The user records are fixed length data structures. The
    keys can be of arbitrary type (integer, floating point number, character
    string or any other objects). RSIS uses a balanced tree algorithm to
    maintain the indices. One index tree is built for each key. When a new
    record is inserted or deleted, all trees are updated accordingly. RSIS is
    memory efficient. It uses 8 bytes per record for each index.

    RSIS_init allocates a memory area for the RSIS local structure if "lbuf" is
    NULL. Otherwise it uses the area pointed by "lbuf". The size of the RSIS
    local structure is found by calling RSIS_local_buf_size.

    RSIS_init, on success, returns the pointer to an RSIS local structure which
    will be used later as an identifier of this record set for other RSIS
    function calls (the argument "rsid"). It returns NULL on failure.

    RSIS_size returns the buffer size needed by RSIS. "maxn" is the maximum
    number of table entries that can be stored, "n_keys" is the number of keys
    and "rec_size" is the user record size.

    RSIS_insert inserts a new record "new_rec" into the RSIS "rsid" and updates
    the indices. It returns the record index on success or
    RSIS_TOO_MANY_RECORDS on failure.

    RSIS_delete deletes the record of "ind" in the RSIS "rsid" and updates the
    indices, where "ind" is the record index returned from RSIS_insert,
    RSIS_find or RSIS_traverse. It returns 0 on success or RSIS_INVALID_INDEX
    if "ind" is not valid.

    RSIS_find searches for a record, returned in "record" if found, by the
    value of the key, specified by "which_key", of record "key" in RSIS "rsid".
    If there are more than one record with the same key, one of the records
    will be returned. If the key is not found, a neighboring record is
    returned. It returns the record index on success or RSIS_NOT_FOUND if there
    is no record at all.

    RSIS_traverse returns the next record, in "record" if found, to the record
    "ind" in terms of key "which_key" in RSIS "rsid". "dir", specifying the
    traversing direction, can be either RSIS_LEFT (the neighboring records on
    the direction of the smaller key) or RSIS_RIGHT. It returns the record
    index on success or RSIS_NOT_FOUND if there is no specified neighbor.

    RSIS_left and RSIS_right are convenience versions of RSIS_traverse. They
    use the "which_key" of previous RSIS_find or RSIS_traverse and "ind" of the
    return value of the previous RSIS_find, RSIS_traverse RSIS_left or
    RSIS_right.

    RSIS_localize is used for initializing the RSIS local struct using existing
    RSIS data structure in "buf". "compare" is the user supplied comparing
    function. RSIS_localize allocates a memory area for the RSIS local
    structure if "lbuf" is NULL. Otherwise it uses the area pointed by "lbuf".
    The size of the RSIS local structure is found by calling
    RSIS_local_buf_size. On success, RSIS_localize returns the pointer to an
    RSIS local structure which will be used later as an identifier of this
    record set for other RSIS function calls (the argument "rsid"). It returns
    NULL on failure.

    RSIS_get_next_ind returns the record index next to "ind". It returns
    RSIS_NOT_FOUND if there is no such record. RSIS_get_next_ind, starting with
    "ind" = 0, gives us a way to walk through the records without an indexing
    key.

    RSIS_get_record_address returns the pointer to the beginning of the record
    area. This gives us a convenient way to access records by their indices.
    e.g. rec = RSIS_get_record_address + rec_size * index.

    RSIS_local_buf_size returns the size of the RSIS local structure.


    MISC_system_to_buffer accepts command "cmd" and executes it. It is similar
    to the system function except with additional arguments to provide a buffer
    "obuf" of size "bsize" for holding the output. Argument "n_bytes" returns
    the number of bytes of the command execution output.

    MISC_system_to_buffer provides an alternative version of the C "system"
    funcition. Th goals are the following: 1. No shell is invoked: Shell
    independence, no environmental variable reset and more efficient. 2. Better
    control on output: The output can be redirected to a memory buffer. 3.
    Better return info: Process ID and execution failure info.

    By default, MISC_system_to_buffer executes "cmd" without invoking a shell.
    "cmd" can be a string of the following format

	cmd > ofile &

    "&" indicates that "cmd" is executed in background. The output of "cmd",
    from both "stdout" and "stderr", is piped into file "ofile". If file
    "ofile" pre-exists, its contents will be removed. If "&" does not present,
    "cmd" is started in foreground. If "> ofile" does not present, the output
    will be directed to elsewhere as explained later. "cmd" contains the
    command name and a number of arguments separated by spaces. Multi-token
    argument can be quoted by character " or "(" and ")". The latter is easier
    to use in case there are " in the argument. The characters ">" and "&" must
    be separated by spaces.

    If an excutable file name does not start with /, $PATH is used for locating
    the executable file.

    When "cmd" is runnning in foreground, MISC_system_to_buffer will not return
    until "cmd" exits. If "> ofile" does not present, the output goes to stdout
    if bsize = -1 or "obuf" otherwise. In the latter case, only the first bsize
    bytes of the output goes to "obuf" and the remaining bytes are discarded
    (Note that this implies that, if bsize == 0, all output data are
    discarded). The total number of output bytes are returned in "n_bytes". If
    bsize = -2, MISC_system_to_buffer behaves like popen. It does not wait for
    the commands to complete and returns the pipe fd like popen. One then can
    read the fd until the commands terminate. One should clost the fd after
    using it.

    When "cmd" is runnning in foreground, MISC_system_to_buffer returns the
    status of the "cmd" on success as does the "system" function or a negative
    error code (see macro MISC_SYSTEM_* defined in misc.h).

    When "cmd" is runnning in background, the last three arguments are ignored.
    MISC_system_to_buffer will return after starting "cmd". On success it
    returns the pid of "cmd". Otherwise a negative error code (see macro
    MISC_SYSTEM_* defined in misc.h) is returned. Returning a non-negative pid
    indicates that "cmd" is successfully launched.

    MISC_system_to_buffer closes all but the the first 3 open file 
    descriptors before running the commands.

    If we want to use MISC_system_to_buffer to run a shell command, we can run
    the shell with the command. For example,

	MISC_system_to_buffer ("sh -c (cd $HOME; ls |grep *.c)", ...);

    MISC_system_setsid enables ("yes" = 0) or disables ("yes" is non-zero) the
    setsid call when starting a process in background. The default is "yes". By
    disabling the call to setsid, the process started will be in the same 
    session as the caller of MISC_system_to_buffer.

    A bug has been found with Solaris/pthread. If a signal is catched while in
    fork and an i/o (printf, fprintf stderr, file ...) is performed in the
    callback function, the application calling fork may block forever. It
    blockes in rw_rdlock which tries to get a mutex lock. I tried to block
    signals before calling fork and recover the sigmask for both child and
    parent. It worked. I removed it since it should not be necesary and we
    don't know how many signals we have to block.


    MISC_cp_open starts a co-process "cmd". Parameter "flag" is no longer used.
    Pipes are set to connect to the co-process for stdin, stdout and stderr.
    Reading of stdout and stderr ports are set to non-blocking. On success, the
    pointer to the co-process struct is returned which can be used for calling
    other MISC_cp functions. The function returns 0 on success or a negative
    error code. This function does not change the signal behavior of the
    calling process. MISC_cp_open does not return an error code when spawning
    the coprocess fails (e.g. the executable does not exist). In this case, the
    following MISC_cp_read_from_cp call will returns an error code, and an
    error message will be sent to stderr (MISC_cp_get_status will return
    MISC_SYSTEM_EXECVP if called).

    The MISC_cp functions provide a convenient way of running and managing
    co-processes. A failed co-process can be detected when calling MISC_cp
    read/write functions. One can run multiple co-processes and can run them
    remotely with RPC. The limitation of using MISC_cp is the possible
    buffering of the standard ports. The co-process must call fflush after
    writing each line to stdout or set buffer size to 0 (using setvbuf). The
    co-process must access the standard input/output ports frequently and
    terminate when a broken pipe is detected if we want the co-process not to
    outlive the main process too long in case the main process fails or is
    killed unexpectedly.

    The coprocess is managed by the main process as a child. One can call
    MISC_cp_get_status to get the coprocess termination status (exit value) if
    the coprocess terminates. A program opening coprocess can not call the
    "system" function on Linux.

    MISC_cp_close terminates the co-process "cp" and frees up all resources.
    This function also terminates all processes that are started from "cp" and
    running in foreground.

    MISC_cp_get_status returns the coprocess termination status (exit value) if
    the coprocess has already terminated. If the coprocess is still running, 0
    is returned.

    MISC_cp_read_from_cp reads a line from the output, stderr or stdout, of the
    co-process and puts it in "buf" of size "b_size". If b_size if too small to
    hold the line, the first part of the line is returned and the next call
    will return the next segment of the line. The returned line is always
    null-terminated. "\n" is the last character if a complete line is returned.
    The read is non_blocking. If no line is ready, it returns 0. It reads
    stderr first. It returns MISC_CP_STDERR or MISC_CP_STDOUT to indicated
    where the line is read from. If an error is detected, it terminates the
    co-process and returns error code MISC_CP_DOWN. If the co-process is
    terminated by a signal, if returns MISC_CP_DOWN. To let
    MISC_cp_read_from_cp return a string without waiting for a line return, one
    can set the MISC_CP_MATCH_STR bit in "b_size" (b_size | MISC_CP_MATCH_STR),
    and put a string-to-be-matched in "buf" when calling this function.

    MISC_cp_write_to_cp writes null-terminated string "str" to the stdin of the
    co-process "cp". It will block until success. If an error is detected, it
    terminates the co-process and returns error code MISC_CP_DOWN. It returns 0
    on success.


    MISC_log provides a logging mechanism for libinfr functions to report
    exceptional conditions. Additional info such as time stamp and errno can be
    logged. The log message goes to stderr by default. By option, it can be
    sent to a caller registered callback function. MISC_log_reg_callback
    registers a callback function for redirecting the log message. If "log_cb"
    is NULL, the log message goes to stderr again. MISC_log_disable (1)
    increases the disable level while MISC_log_disable decreases it. If the
    disable level is greater than 0 and the code is not in the EN callback, 
    MISC_log is disabled (do nothing).

    MISC_log should be used only in conditions where additional info (e.g.
    errno) is available and fatal exceptional conditions. Excessive number of
    log messages can be difficult to use.


    MISC_write, MISC_read, MISC_close, MISC_open, MISC_unlink, MISC_stat,
    MISC_fstat, MISC_system, MISC_fopen and MISC_fclose are wrapped versions of
    the corresponding system functions. These functions are the same as the
    corresponding system functions except they are interrupt insensitive: They
    continue to work, instead of terminated prematurely, in case that they are
    interrupted by a signal These functions are used by other libinfr
    functions.


    MISC_bsearch searches for an entry in the table "tbl" of size "tbl_size"
    that equals (in terms of "cmp") "ent". The size of each item in the table
    is "item_size". If found, returns 1 and "ind" set to the first found entry.
    Otherwise, returns 0 and "ind" set to the first entry that is greater than
    "ent". The table must be in non-decreasing order. Refer to 
    MISC_table_search for a decription of the comparison function. This is an
    enhanced version of bsearch and shares the same comparison function with
    the latter.


    MISC_malloc is a "malloc" function with error handing. The caller of this
    function does not need to perform exception handing. When the requested
    memory resource is not available, this function either retries periodically
    or terminates the process depending on "Malloc_retry" set by
    MISC_malloc_retry. This function prints the size to be allocated and the
    process stack before terminating the process.

    MISC_malloc_retry turns on/off the retry mode in MISC_malloc.


    MISC_compress compresses "src_len" bytes in buffer "src" with "method".
    Buffer "dest" of size "dest_len" returns the compressed data. The valid
    values for "method" are MISC_GZIP or MISC_BZIP2 (misc.h). It returns the
    number of bytes of the compressed data on success or a negative error code
    on failure. Error code MISC_BUF_TOO_SMALL indicates that the size of
    "dest", "dest_len", is not large enough for holding the compressed data.
    Other error return values are listed in misc.h. Any error code, from the
    gzip/bzip2 functions, except for MISC_BUF_TOO_SMALL, is logged with
    MISC_log.

    MISC_decompress decompresses "src_len" bytes in buffer "src" with "method".
    Buffer "dest" of size "dest_len" returns the decompressed data. The valid
    values for "method" are MISC_GZIP or MISC_BZIP2 (misc.h). It returns the
    number of bytes of the decompressed data on success or a negative error
    code on failure. Error code MISC_BUF_TOO_SMALL indicates that the size of
    "dest", "dest_len", is not large enough for holding the compressed data.
    Other error return values are listed in misc.h. Any error code from the
    gzip/bzip2 functions, except for MISC_BUF_TOO_SMALL, is logged with
    MISC_log.


SEE ALSO
    infr(3)

NOTES
    Usefulness of some of the functions are subject to review.





