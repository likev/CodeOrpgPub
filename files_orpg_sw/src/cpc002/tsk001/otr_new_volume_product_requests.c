/**************************************************************************

   Module:   otr_new_volume_product_requests.c

   Description: 
             
   These routines handle the one time product requests
   for current products.  A request may ask for a number of current products
   with another number indicating the number of volumes between the
   sending of this product. The requests may come from either users, or
   by the automatic alert paired product logic.
   These requests can be filled with 1.) products
   that have already been generated from the current or previous volume
   scan. 2.) products generated by "replay" tasks that use raw data
   from the current or previous volume scan and/or 3.) products scheduled
   and generated in realtime. 

   When a new request comes into the system, OTR_add_to_volume_requests
   is called.  This checks the current and previous volume for the product.
   If it's there, then a response is made.  Otherwise it is added to the
   list of outstanding onetime requests.
   
   Once all the messages from the onetime request LB have been processed,
   and at periodic intervals, the OTR_replay_timeout_check should be called.
   It sends the outstanding requests to the replay processes.  Requests
   that are not filled by the replay processes  and requests for a product
   from more than one volume scan, are scheduled for generation
   from the real-time data.
   Any timed-out requests are removed with an error message sent to the
   user that requested it.
   
   When products are posted from replay, OTR_replay_message_received should
   be called to send the product message to the requester. If replay responds
   with an error, then the product is scheduled on the real-time stream.
   
   When the product status has changed, OTR_product_status_update  should be
   called to check for replies that can be made from the realtime data.
   
   Should the requests  from a line need to be canceled (e.g. The
   line for the user that made the request goes down), then
   OTR_remove_volume_requests is called to remove all requests from this
   line.
      
   Each time a volume is ended, OTR_new_volume_product_requests should
   be called.  This builds a new product creation message and sends it 
   to the realtime product scheduler, and removes requests from the list 
   that have expired.

   OTR_update_elevation_data should be called at the start of ps_onetime
   execution to initialize the elevation data.
   
   Assumptions:

   **************************************************************************/

/*
 * RCS info
 * $Author: steves $
 * $Locker:  $
 * $Date: 2012/07/19 22:20:47 $
 * $Id: otr_new_volume_product_requests.c,v 1.98 2012/07/19 22:20:47 steves Exp $
 * $Revision: 1.98 $
 * $State: Exp $
 */

/*
 * System Include Files/Local Include Files
 */


#include <assert.h>
#include <stdlib.h>
#include <time.h>
#include <orpg.h>
#include <prod_distri_info.h>
#include <otr_new_volume_product_requests.h>
#include <otr_reply_to_request.h>
#include <gen_stat_msg.h>
#include <prod_status.h>
#include <le.h>
#include <a309.h>
#include <prod_gen_msg.h>
#include <otr_main.h>
#include <prod_request.h>
#include <orpgpat.h>
#include <otr_alert_paired_product_request.h>
#include <otr_new_volume_product_requests.h>
#include <mrpg.h>
#include <rpg_vcp.h>

/*
 * Constant Definitions/Macro Definitions/Type Definitions
 */
  /* note: The following timeout plus the time in
   * the "sleep" call in otr_main must be less than
   * 90 seconds to meet the onetime request response
   * time requirement.
   */ 
#define  REPLAY_TIMEOUT 84
#define  CFC_REPLAY_TIMEOUT (15*60)
  /* the CFC product timeout is 15 minutes */

/* this defines an element in a list of requests to be fulfilled */
typedef struct list_el {

   void *next;			/* pointer to next element in the list */
   void *prev;			/* pointer to previous element in the list */
   int server_id;		/* p_server_id to send replies to.  This is
                                   set to -1 for requests where the product
                                   is to be generated but not distributed.
                                   e.g. CFC product from a dial-in line. */
   Pd_msg_header header; 	/* copy of the message header for the request */
   Pd_request_products request; /* copy of the request message for the request */
   int interval_counter;	/* used to count volumes between times to get 
                                   another product */
   int product_counter;		/* used to down-count the number of products to 
                                   fulfill request */
   unsigned int requested_for_this_volume;	/* the volume number the next product is
                                                   to come from */
   time_t requested_time; 	/* time request was made used to compute replay 
                                   request timeout */	
   int request_made;   		/* Keeps the state of the request, NO_REQUESTS, 
                                   REPLAY_REQUEST_MADE or REALTIME_REQUEST */                                					 
} Table_list;

/* this defines the structure of the message to routine product generation */
typedef struct routine_product_request {

   Pd_msg_header   routine_product_header;
   Pd_request_products routine_request[1000];

}  Routine_product_request;

/* Global variables. */
long last_volume_time = -1;  
                      /*seconds past midnight for last volume start -1 mean not yet set */
Pd_general_status_msg Cr_gsm;	/* current RDA/RPG status */

unsigned long Vol_number_in_rda_stat = 0;           
                      /* latest volume number in rda status message*/

/* Static Globals */
static Table_list *Request_list_first = NULL;  
                       /* pointer to list of requests */

static Routine_product_request *Current_request_message = NULL;	
                       /* pointer to message to send to ps_routine to schedule product generation. */

static int Current_request_number = 0;	/* number of requests in realtime list */
static int Realtime_list_size = 0;	/* size of Current_request_message in bytes */

static Prod_request *Replay_request_message = NULL; 
                      /* pointer to the message for to send to replay scheduler */

static int Current_replay_number = 0;   /* number of requests in replay message */
        /* note that when scheduling a product for a volume, the number from the rda status
         * message is the one that has just started.  The latest in the product status may
         * lag by a few seconds.  So, to schedule, use Vol_number_in_rda_stat, to check for
         * an available product from the right volume, use Vol_number_in_prod_stat. */

static unsigned int Vol_number_in_prod_stat = 0;        
                      /* latest volume number in product status message*/

/*
 * Static Function Prototypes
 */
int             add_request_to_realtime_message(Pd_request_products *request,
                                                Table_list *this_entry);
void            add_request_to_replay_message(Pd_request_products *request);
Table_list*     release_from_list(Table_list *pointer);
void            rebuild_request_message();
int             get_elev_param_index(int prod_id);
int             get_elevation_index(int elev);
Table_list*     release_from_replay_list(Table_list *pointer);
void            send_replay_message();
void            build_and_send_new_replay_message();
void            Post_realtime_request();

/**************************************************************************
   Description: This function first checks the product status LB for a current
   product that fulfills the request, if so it sends the reply.  If not (or
   more than one product was requested), it adds a request to the request lists.

   Input:
      p_server_id is the instance number of the p_server that should receive the reply
      message_header is the header for the request.
      request is the request message.

   Output:
     Replies to requests via OTR_reply_to_request routine.
     Generation messages to the real-time and replay streams.

   Returns: void

   Globals:  Request_list_first, Current_request_message

   Notes:

**************************************************************************/
void OTR_add_to_volume_requests( int p_server_id, Pd_msg_header *message_header,
                                 Pd_request_products *request ){

   int sent_message = 0;	
   int last_flag = 0;
   int volume_number = 0; 
    
   sent_message = OTR_check_product_status( p_server_id, message_header, request,
                                            &last_flag, &volume_number );

   /* Clear the SUPPLEMENTAL_SCAN_BIT if set. */
   if( request->flag_bits & SUPPLEMENTAL_SCAN_BIT )
      request->flag_bits &= ~SUPPLEMENTAL_SCAN_BIT;

   /* Either the request has not yet been satisfied or the number of products
      in the request is greater than 1. */
   if( (sent_message == 0) 
              || 
       (request->num_products > 0) )
      OTR_make_volume_request( p_server_id, message_header, request,
                               sent_message, volume_number );

} /* End of OTR_add_to_volume_requests() */


/**************************************************************************
   Description: This function checks the product status LB for a current
   product that fulfills the request, if so it sends the reply.  

   Input:
      p_server_id - the instance number of the p_server that should receive the reply
      message_header - the header for the request.
      request - the request message.

   Output:
     volume number - current volume number from product status.

   Returns: 
      Always returns 0.

   Notes:
**************************************************************************/
int OTR_make_volume_request( int p_server_id, Pd_msg_header *message_header, 
                             Pd_request_products *request, int sent_message,
                             int volume_number ){

   int task_state;
   int instance = 0;
   int get_state_return=0;
   int last_flag;
   int error_flag;
   int retval;
   char *task_name;

   Table_list *new_entry = NULL;
   
   /* If a response to the request still has not been made, then the product 
      was not listed in the product status.  Tell the user if this product
      can not be generated on the real-time stream owing to the fact the 
      task was not loaded or the task failed. */
   if( sent_message == 0 ){

      task_name = ORPGPAT_get_gen_task( request->prod_id );
      get_state_return = ORPGMGR_get_task_status(task_name, instance, &task_state);
      if ( 0 != get_state_return ){

         LE_send_msg( GL_INFO | LE_VL1, "Error %d getting state for task %s, product %d \n",
                  	   get_state_return, task_name, request->prod_id);
         last_flag = 1;
         error_flag = OTR_TASK_NOT_STARTED; 
         OTR_reply_to_request( p_server_id, request, message_header, 0, request->prod_id,
                               0, error_flag, last_flag );
         sent_message = 1;
         request->num_products = 0;	  

      } 
      else if( (task_state != MRPG_PS_ACTIVE) &&  (task_state != MRPG_PS_STARTED) ){

         /* task is not running, send error message */
         last_flag = 1;
         error_flag = OTR_TASK_FAILED;
         if (task_state == MRPG_PS_NOT_STARTED)
            error_flag = OTR_TASK_NOT_STARTED;

         OTR_reply_to_request( p_server_id, request, message_header, 0, 
                               request->prod_id, 0, error_flag, last_flag );
         LE_send_msg( GL_INFO | LE_VL1, 
            	   "product %d task %s is not running, state is %d \n",
           	   request->prod_id, task_name, task_state);
          
         sent_message = 1;
         request->num_products = 0;

      }
      else
         LE_send_msg( GL_INFO | LE_VL3,
              		"^^^Requested Product %d task is running \n",request->prod_id);
             
   }

   /* If the user does not have the privelege to generate products, no need to go 
      any further. */
   if( (sent_message == 0) && ((request->flag_bits & NON_SCHEDULING_REQUEST_BIT) != 0)){ 

      /* was not able to send a reply, if the user does not have
         the privelege to request product generation, then send an error message */
      last_flag = 1;
      error_flag = OTR_PRODUCT_NOT_AVAILABLE;
      OTR_reply_to_request( p_server_id, request, message_header, 0, request->prod_id, 0,
			    error_flag, last_flag );
      LE_send_msg( GL_INFO | LE_VL2, 
                   " no product found and not permitted to schedule \n");
   }
   else if (request->num_products > 0){

      /* still have products that should be sent, first see if the product is 
         one that can be generated on the replay stream */
      char *task_name;
      int task_state;
      int made_request = NO_REQUESTS;
      int instance = 0;
	   
      if (request->prod_id != CFCPROD){

         task_name = ORPGPAT_get_gen_task(request->prod_id);
   
         if( strstr( task_name, "replay_" ) == NULL ){

            char *cp = task_name;
            
            task_name = malloc( strlen("replay_") + strlen( cp ) + 1 );
            if( task_name == NULL ){
            
                LE_send_msg( GL_ERROR | LE_VL3, "task_name == NULL\n" );
                ORPGTASK_exit(GL_MEMORY);

            }

            strcpy( task_name, "replay_" );
            strcat( task_name, cp );
          
            retval = ORPGMGR_get_task_status(task_name, instance, &task_state);
            free( task_name );

          }
          else
             retval = ORPGMGR_get_task_status(task_name, instance, &task_state);

          /* get replay product task id */
   
         if ( (0 != retval) || (task_state != MRPG_PS_ACTIVE) ) {
          
            if (request->seq_number != ALERT_PAIRED_PRODUCT_SEQUENCE_NUMBER){ 	          
               /* there is no replay task, just pass to realtime stream for generation
                  on next volume */	          
               made_request = REALTIME_REQUEST;

               /* If no message has been sent for this request, must tell p_server to send
                  out RR message. */
               if( sent_message == 0 )
                  OTR_reply_to_request( p_server_id, request, message_header, 0, request->prod_id, 0,
                                        OTR_NEXT_VOLUME, 0 );
            }
            else {
               /* this is an alert product that is not replay-able, wait for replay 
                  timeout for it to appear in the product status anyway.  This assumes
                  that all non-replayable alert paired products are scheduled all the time. */
               made_request = ALERT_SCHEDULED;
            }

         }

      }
      else {

         /* This is a CFCPROD request, if it's made it this far, the CFC will not be 
            available from the replay stream until the begining of the next volume scan, 
            so send the RR message.  Note: other products get RR when replay times out */
         OTR_reply_to_request( p_server_id, request, message_header, 0, request->prod_id, 0,
                               OTR_NEXT_VOLUME, 0 );            

      }

      new_entry = OTR_add_request_to_request_list( p_server_id, message_header, request,
                                                   sent_message, &made_request, volume_number );

      /* Verify new_entry is not NULL.   It should NEVER be NULL. */
      if( new_entry == NULL ){

         LE_send_msg( GL_MEMORY | LE_VL3, "new_entry == NULL ... coding error.\n" );
         ORPGTASK_exit(GL_MEMORY);

      }

      /* schedule realtime request if it has not already been scheduled */
      if( made_request == REALTIME_REQUEST )
         OTR_post_realtime_onetime_request( p_server_id, request, new_entry );

   }

   return 0;

}
     

/**************************************************************************
   Description: This function adds a request to the request list.  It also
                posts the request if the request is REALTIME and not already 
                posted.

   Input:
      p_server_id - the instance number of the p_server that should receive the reply
      message_header - the header for the request.
      request - the request message.
      sent_message - flag indicating whether response to request sent.
      made_request - flag indicating whether request was made of not. 
      volume number - current volume number from product status.

   Output:

   Returns: 
      Always pointer to new Table_list entry.

   Notes:
**************************************************************************/
void* OTR_add_request_to_request_list( int p_server_id, Pd_msg_header *message_header,
                                       Pd_request_products *request, int sent_message,
                                       int *made_request, int volume_number ){

   Table_list *new_entry;

   /* Add the request to the list of outstanding requests, first create an entry from
      the heap; */
   new_entry = (Table_list *) malloc (sizeof(Table_list));
   if (new_entry == NULL) {

      LE_send_msg(GL_MEMORY | LE_VL0, 
             "memory allocation failed for replay queue in OTR_add_to_volume_requests \n");
      ORPGTASK_exit(GL_MEMORY);
   }

   new_entry->request = *request;
   new_entry->server_id = p_server_id;
   new_entry->header = *message_header;
   new_entry->requested_time = time(0); /* for computing time-out of replay*/

   if( volume_number == VOLUME_NUMBER_UNDEFINED )
      volume_number = Vol_number_in_prod_stat;        

   if (sent_message != 0){

      *made_request = REALTIME_REQUEST;
      new_entry->interval_counter = request->req_interval;
      new_entry->requested_for_this_volume = volume_number +  request->req_interval;

   }
   else{

      new_entry->interval_counter = 0;
      new_entry->requested_for_this_volume = volume_number;

   }

   new_entry->request_made = *made_request;
   new_entry->product_counter = request->num_products;

   LE_send_msg( GL_INFO | LE_VL3, "The Following Request Added to Request List:\n" );
   LE_send_msg( GL_INFO | LE_VL3, "--->Prod ID: %d, Volume_Requested: %d, Product Counter: %d\n",
                request->prod_id, new_entry->requested_for_this_volume, new_entry->product_counter );

   /* now add the entry to the request list */
   new_entry->next = NULL;
   new_entry->prev = NULL;
   if (Request_list_first != NULL){

      Request_list_first->prev = new_entry;
      new_entry->next = Request_list_first;

   }

   Request_list_first = new_entry;
   return( (void *) new_entry );

} /* End of OTR_add_request_to_request_list() */
  
/**************************************************************************
   Description: This function adds a request to the request lists.

   Input:
      p_server_id - the instance number of the p_server that should receive the reply
      message_header - the header for the request.
      request - the request message.

   Output:
     last_flag - indicates whether there are any more requests. 
     volume_number - the volume number from product status.

   Returns: 
      1 if reply was made, or 0 otherwise.

   Notes:

**************************************************************************/
int OTR_check_product_status( int p_server_id, Pd_msg_header *message_header,
                              Pd_request_products *request, int *last_flag,
                              int *volume_number ){

   int i;				/* index for loop to search for product */
   int status;				/* status of LB operations */
   int sent_message;			/* indicates a reply has been sent */
   int supplemental_scan = 0;
   Prod_gen_status_header *product_status = NULL;
   Prod_gen_status *prod_status_array = NULL;
   int error_flag = OTR_PRODUCT_READY; 	/* contains request error flag for reply */
   unsigned int message_id = LB_MAX_ID;	/* message number in the LB that fulfills 
                                           the request */
   /* first see if there is a current product that can be returned, and send it */
   sent_message = 0;
   *last_flag = 1;	/* this will be last message if it can't get status info */

   /* Is the SUPPLEMENTA_FLAG_BIT set? */
   supplemental_scan = request->flag_bits & SUPPLEMENTAL_SCAN_BIT;

   /* get the new product status */
   status = ORPGDA_read( ORPGDAT_PROD_STATUS, (char *) &product_status, LB_ALLOC_BUF, 
                         PROD_STATUS_MSG );

   if( status > 0 ){

      /* This is the current volume.  Save for Replay requests and scheduling. */
      Vol_number_in_prod_stat = product_status->vnum[0];  

      /* point to the status of products in the buffer */
      prod_status_array = (Prod_gen_status *) ( (char *) product_status +
				   ALIGNED_SIZE(sizeof(Prod_gen_status_header)));
      if (request->num_products == 1) 
         *last_flag = 1;

      else
         *last_flag = 0;

      /* search the status for a product of same ID and parameters */
      for (i = 0; ((i < product_status->length) && (sent_message == 0)); i++) {

         /* Match the product ID. */
	 if (request->prod_id == prod_status_array[i].prod_id) {

            /* Compare the product dependent parameters. */
	    if (0 != OTR_compare_parameters(request->params, prod_status_array[i].params,
               request->prod_id)){

               /* Is the supplemental flag set and if so, is the elevation index 
                  in the product status something other than 1 (which indicates 
                  it is the lowest cut).  The assumption here is that supplemental
                  cuts are always a repeat of the lowest cut(s) and the elevation
                  index of the lowest cut is 1. */
               if( supplemental_scan && (prod_status_array[i].elev_index <= 1) )
                  continue;

               /* this product matches the request. get the data to make a reply */
	       if (request->seq_number == ALERT_PAIRED_PRODUCT_SEQUENCE_NUMBER) {

	          /* this is an alert paired product, so get the correct volume number */
	          int ivol_index; 

	          for (ivol_index = 0; ivol_index < 2; ivol_index++){

		     if (product_status->vnum[ivol_index] == request->VS_start_time) {

		        message_id = prod_status_array[i].msg_ids[ivol_index];
		        *volume_number = product_status->vnum[ivol_index];
		        LE_send_msg( GL_INFO | LE_VL3, 
                                     "--->Alert Product %d Message Product Status: %d \n",
                                     request->prod_id, message_id );
		        break;

                     }

                  }
		     
               }
               else{

	          /* Note: May need to change msg_ids subscript to symbols 
                           PS_DEF_CURRENT_VOLUME and PS_DEF_PREVIOUS_VOLUME
	                   defined in ps_def.h, but that would make it
		           a global include file. */
		      
	          message_id = prod_status_array[i].msg_ids[0];

                  /* The current volume is stored in product_status->vnum[0] */
                  *volume_number = product_status->vnum[0];

	          if ((message_id >= LB_MAX_ID) && (prod_status_array[i].msg_ids[1] < LB_MAX_ID) ){

	             /* no product in current volume, check previous */			         
	             message_id = prod_status_array[i].msg_ids[1];
		     *volume_number = product_status->vnum[1];

	          }

               }

	       if (message_id < LB_MAX_ID) {

	          /* this is a good product, send the reply */
	          error_flag = OTR_PRODUCT_READY;

                  /* Reply to p_server with the volume scan that satisfied the
                     request.  It could be either the current or previous volume 
                     scan. */
	          OTR_reply_to_request( p_server_id, request, message_header, 
                                        *volume_number, request->prod_id, (int) message_id, 
                                        error_flag, *last_flag );
	          LE_send_msg( GL_INFO | LE_VL2, 
                               "--->Sent Reply For Product ID %d From Current or Previous Volume (%d)\n",
                               request->prod_id, *volume_number );				
	          sent_message = 1;
	          request->num_products--;
		       
	       }
	       else if( message_id == PGS_DISABLED_MOMENT ){

		  error_flag = OTR_DISABLED_MOMENT;
		  LE_send_msg(GL_INFO | LE_VL3,
		            "status message shows no Moment \n");
			        
		  OTR_reply_to_request( p_server_id, request, message_header,
		  	                *volume_number, request->prod_id, (int) message_id,
				        error_flag, *last_flag );
		  sent_message = 1;
		  request->num_products--;

               }
	       else if( (message_id == PGS_TASK_NOT_RUNNING) ||
		        (message_id == PGS_TASK_FAILED) ||
		        (message_id == PGS_TASK_SELF_TERM) ||
		        (message_id == PGS_PRODUCT_NOT_GEN) ||
		        (message_id == PGS_SLOT_UNAVAILABLE) ||
		        (message_id == PGS_INVALID_PARAMS) ||
		        (message_id == PGS_INAPPR_WX_MODE) ){

		        /* on these errors, we can reply at once. 
                           set the error flag to the right reason */
		            
	          if (message_id == PGS_TASK_NOT_RUNNING) {

		     error_flag = OTR_TASK_NOT_RUNNING;
		     LE_send_msg(GL_INFO | LE_VL3,
			            "status message shows PGS_TASK_NOT_RUNNING \n"); 
	          } else if (message_id == PGS_TASK_FAILED) {

		     error_flag = OTR_TASK_FAILED;
		     LE_send_msg(GL_INFO | LE_VL3,
			            "status message shows PGS_TASK_FAILED \n");
		  } else if (message_id == PGS_TASK_SELF_TERM) {

		     error_flag = OTR_TASK_SELF_TERM;
		     LE_send_msg(GL_INFO | LE_VL3,
			            "status message shows PGS_TASK_SELF_TERM \n");
	          } else if (message_id == PGS_PRODUCT_NOT_GEN) {

		     error_flag = OTR_PRODUCT_NOT_GEN;             
		     LE_send_msg(GL_INFO | LE_VL3,
			            "status message shows PGS_PRODUCT_NOT_GEN \n");
		  } else if (message_id == PGS_SLOT_UNAVAILABLE) {

		     error_flag = OTR_SLOT_FULL;             
		     LE_send_msg(GL_INFO | LE_VL3,
			            "status message shows PGS_SLOT_UNAVAILABLE \n");
	          } else if (message_id == PGS_INVALID_PARAMS) {

		     error_flag = OTR_INVALID_PARAMS;             
		     LE_send_msg(GL_INFO | LE_VL3,
			            "status message shows PGS_INVALID_PARAMS \n");
		  } else if (message_id == PGS_INAPPR_WX_MODE)  {

		     error_flag = OTR_DISABLED_MOMENT;
		     LE_send_msg(GL_INFO | LE_VL3,
			            "status message shows wrong mode \n");
			        
		  }

		  OTR_reply_to_request( p_server_id, request, message_header,
		  	                *volume_number, request->prod_id, (int) message_id,
				        error_flag, *last_flag );
		  sent_message = 1;
		  request->num_products = 0;

              }

           }

        }

     }

     free((void *) product_status);

   }

   return( sent_message );

} /* End of OTR_check_product_status() */

/**************************************************************************
   Description:  Checks all messages on the replay response lb, and
                 sends replies to the requester if the product applies.
                 
   Input:  None
   Output: onetime product responses.
   Returns: if there may be a message on the reply LB that already has
             the event posted, then return 1, if the LB is truly empty
             return 0.  This allows the main loop to always call this
             when there may be a message to read.
           
   Globals: 
   Notes:
**************************************************************************/
int OTR_replay_message_received(){

	Prod_gen_msg   *product_reply = NULL;
	Table_list     *pointer;/* used to run through the replay list to
				 * find requests for this product */
	int             send_new_replay_message = 0;
	int		send_new_realtime_message = 0;
	int             last_flag;
	int             error_flag;
	int             status; /* status of response lb read, also used to exit the read loop */
	int             return_value = 0;  /* value to return */
        
        /* get the replay reply messages */
        status = 0;       
      	while( status >= 0 ){
	     status = ORPGDA_read(ORPGDAT_REPLAY_RESPONSES, (char **)&product_reply,
				     LB_ALLOC_BUF, LB_NEXT);
	     if (status != sizeof(Prod_gen_msg)){
	         if ((status != LB_NOT_FOUND) && (status != LB_TO_COME)){
		    LE_send_msg(GL_INFO | LE_VL1, "error on read from replay lb, status %d \n", 
	                        status);
	             if (status >= 0){
	                 free ((void *) product_reply);
	                 status = -1;
	             }
	         }
	         else{
		     if (status == LB_TO_COME){ 
	                 return_value = 1;  /* this is to say that another call should be made to this
	                                     * routine after a short time delay */
	             }
	             else{
		         LE_send_msg(GL_INFO | LE_VL3, "end of messages from replay lb, status %d \n",status);
	             }
	         }
	     }
	    if (status > 0){
	      
	      LE_send_msg(GL_INFO | LE_VL3, 
	           "Product %d received from replay, with message %d, param %d %d %d %d %d %d\n", 
	                      product_reply->prod_id, product_reply->id,
	                      product_reply->req_params[0], product_reply->req_params[1],
	                      product_reply->req_params[2], product_reply->req_params[3],
	                      product_reply->req_params[4], product_reply->req_params[5]);
              /* search for outstanding requests that can be filled by the product from replay */
	      pointer = Request_list_first;
	      while (pointer != NULL) {
	        int sent_message = 0;
	        
	        if ( (pointer->request_made == REPLAY_REQUEST_MADE) &&
	                (pointer->request.prod_id == product_reply->prod_id) &&
	                (0 != OTR_compare_parameters(pointer->request.params,
	                product_reply->req_params, pointer->request.prod_id))) {
	                    
	            /* indicate a new replay message can be sent */
	            send_new_replay_message= 1;

	            if (product_reply->len > 0) {

	            /*
	             * product matches, send reply to
	             * requester
	             */
	                LE_send_msg(GL_INFO | LE_VL2,
	                    " replay responded, product %d, message_id %d \n",
	                     pointer->request.prod_id, product_reply->id);
	                if (pointer->request.num_products <= 1) {
	                    last_flag = 1;
	                } 
	                else {
	                    last_flag = 0;
	                    send_new_realtime_message = 1;
	                }

	                OTR_reply_to_request(pointer->server_id,
	                    &(pointer->request),
	                    &(pointer->header),
	                    product_reply->vol_num,
	                    pointer->request.prod_id,
	                    product_reply->id,
	                    OTR_PRODUCT_READY,
	                    last_flag);
	                sent_message = 1;
	                pointer->request_made = REALTIME_REQUEST;
	                pointer->requested_for_this_volume = product_reply->vol_num + pointer->request.req_interval;
	                pointer->interval_counter = pointer->request.req_interval;
	              }
	              else if (pointer->request.seq_number == ALERT_PAIRED_PRODUCT_SEQUENCE_NUMBER){
	                   /* alert paired product not available from replay, and wasn't in
	                      the status message at the time it was requested, send data not available message
	                    */
	                    
	                LE_send_msg(GL_INFO | LE_VL2,
	                    " replay responded but had error on alert product, product %d, message_id %d \n",
	                     pointer->request.prod_id, product_reply->id);
	                last_flag = 1;
	                pointer->product_counter=0;
	                OTR_reply_to_request(pointer->server_id,
	                    &(pointer->request),
	                    &(pointer->header),
	                    product_reply->vol_num,
	                    pointer->request.prod_id,
	                    product_reply->id,
	                    OTR_PRODUCT_NOT_AVAILABLE,
	                    last_flag);
	                sent_message = 1;
	                    
	                    
	                    
	              }
	              else {
	                /*
	                 * error in replay generation - allow
	                 * realtime stream to reply. Send
	                 * notification that it's coming next
	                 * volume
	                 */
	                LE_send_msg(GL_INFO | LE_VL2,
	                      " replay responded, but had error, product %d, error_id %d \n",
	                     pointer->request.prod_id, product_reply->len);
	                error_flag = OTR_NEXT_VOLUME;
	                OTR_reply_to_request(pointer->server_id,
	                    &(pointer->request),
	                    &(pointer->header),
	                    0,
	                    pointer->request.prod_id, 0,
	                    error_flag, 0);
	                pointer->request_made = REALTIME_REQUEST;
	                pointer->interval_counter = 0;
	                send_new_realtime_message = 1;
	              }
	              
	              /* if this is the last product to be sent for this request, 
	                 then release the request */
	              	              
	              if ((sent_message ==1) && (pointer->product_counter-- <= 1)){
	                   pointer = release_from_list(pointer);
	                   send_new_realtime_message = 1;
	              }
	              else{
	              
	                    pointer =pointer->next;
	              } 

	            } 
	            else {
	                pointer = pointer->next;
	            }
	        } /* end search through all replay requests */
	        free ((void *)product_reply);
	    } /* end read check on lb */
	} /* end for all messages on the LB */
	
	/* if the outstanding requests have changed, send new scheduling messages
	   to replay and/or realtime scheduler as needed */
	if (send_new_replay_message == 1) {
	    build_and_send_new_replay_message ();
	}

	if (send_new_realtime_message == 1)
           Post_realtime_request();

	 return (return_value);
}

/**************************************************************************
   Description: Checks all replay requests for timeout, and builds new
                replay requests.  This allows for some queuing of onetime
                requests in the list, while allowing for additional replay
                requests to be made when a request may take a long time.
   Input: 
   Output: 
   Returns: void
   Globals: Request_list_first
   Notes:
**************************************************************************/
void OTR_replay_timeout_check(){

   	Table_list     *pointer;/* used to run through the outstanding request list */
	time_t check_time;
	int release_item;
	int need_new_realtime_request = 0;
				 
	pointer = Request_list_first;
	check_time = time(0);
	while (pointer != NULL) {

	    release_item = 0;

	    if (pointer->request.prod_id == CFCPROD){
	       /* the CFC product is special.  It is only available from
	        * the replay stream, and its timeout can be 15 minutes.
	        * If it does time out, send a reply that the product was
	        * not generated, and delete it from the list 
	        */
	        if ((check_time - pointer->requested_time) > CFC_REPLAY_TIMEOUT){
	        
	           LE_send_msg(GL_INFO | LE_VL2, "CFC product replay timed out \n");
		   OTR_reply_to_request(pointer->server_id,
					&(pointer->request),
					&(pointer->header),
					0,
					pointer->request.prod_id, 0,
					OTR_PRODUCT_NOT_AVAILABLE, 1);
                   release_item = 1; /* release from list at bottom of loop */
                }
	    
	    }
	    else if ( ((pointer-> request_made == REPLAY_REQUEST_MADE) ||
	              (pointer-> request_made == ALERT_SCHEDULED) )  &&
	             ((check_time - pointer->requested_time) > REPLAY_TIMEOUT)){
	       /* this entry has timed out, send notification that
	        * the reply will come in the next volume scan
	        */
		LE_send_msg(GL_INFO | LE_VL2,
			" replay timed out, reply from next realtime volume: product %d \n",
			pointer->request.prod_id);
		OTR_reply_to_request(pointer->server_id,
					&(pointer->request),
					&(pointer->header),
					0,
					pointer->request.prod_id, 0,
					OTR_NEXT_VOLUME, 0);
		pointer->request_made = REALTIME_REQUEST;
		/* get the next volume's product, whatever the volume number may be */
		pointer->requested_for_this_volume = 0;
		pointer->interval_counter = 0;
		need_new_realtime_request = 1;
	    }
	    
	    if (release_item == 1){
	       pointer = release_from_list(pointer);
	    }
	    else{
 	       pointer = pointer->next;
 	    }
	}
	/* make and send new replay and realtime scheduling messages */
	build_and_send_new_replay_message();
	if (need_new_realtime_request)
           Post_realtime_request();

	return;
}

/**************************************************************************
   Description: Removes all requests from the list from a specific line.
                Except those that were set for generation and not distribution.
   Input: The message header that canceled the requests.
   Output: Updated product requests via ORPGDAT_RT_REQUEST LB.
   Returns: void
   Globals: Request_list_first
   Notes:
**************************************************************************/
void OTR_remove_volume_requests(Pd_msg_header * message_header){

   Table_list     *pointer;	/* used to run through the list to find
				 * requests from this line_ind */
   int removed = 0;   /* used to tell if a new request message should be sent */
    
   pointer = Request_list_first;
   while (pointer != NULL) {

      if( (pointer->header.line_ind == message_header->line_ind) &&
	  (pointer->server_id >=0 )){

         pointer = release_from_list(pointer);
	 removed = 1;

	}
        else 
	   pointer = pointer->next;
	
   }
       
   if (removed == 1)
      Post_realtime_request();

}
/**************************************************************************
   Description:  Performs request processing for new volumes. First removing
                 requests from the list that have received no response
                 in several volumes. Then making a new request for
                 products that are requested for the new volume.
   Input: General status message through the ORPGDAT_GSM_DATA LB.
   Output: product requests to the product scheduler via LB
   Returns: void
   Globals: Request_list_first
   Notes:
**************************************************************************/
void OTR_new_volume_product_requests(){

   Table_list     *this_entry;	/* pointer to request entry we are acting
				 * upon */
   int status;
   int task_status;
   int error_flag;
   int elev_param = -1;
   int elev_flag_req = 0;
    
   /* first update all the RDA status variables */
   OTR_update_elevation_data();

   /* if there were no requests, then just return */
   if (Request_list_first == NULL) 
	return;

   /* look through all the request on the list for those needing update */
   this_entry = Request_list_first;
   while (this_entry != NULL) {

      /* This flag, when set, indicates the elevation parameter of the request
         has one of the ORPGPRQ_ELEV_FLAG_BITS set.  Clear the flag initially. */
      elev_flag_req = 0;

      /* Is this a real-time request? */
      if (this_entry->request_made == REALTIME_REQUEST){

         /* If this product is elevation-based and has an elevation parameter,
            check if the elevation parameter contains special flag values.
            If yes, decrement the product counter.   We do this here because
            no response can match this request and there is no other mechanism
            to decrease the counter. */
         if ((elev_param = ORPGPAT_elevation_based( this_entry->request.prod_id )) >= 0 ){

            if( this_entry->request.params[elev_param] & ORPGPRQ_ELEV_FLAG_BITS ){

               elev_flag_req = 1;
               this_entry->product_counter--;

            }

         }
         
	 if (this_entry->product_counter <= 0) {

	    /* no more products for this request - release this entry from list */
	    this_entry = release_from_list(this_entry);

         } 
	 else {

	    /* update interval counter */
	    if( !elev_flag_req && 
                (this_entry->interval_counter-- < (-1 * this_entry->request.req_interval))) {

	       /* when the interval counter is negative by the request interval, 
                  then no product has been made in the past two intervals, need 
                  to send an error to the user.  This is done this way so that 
                  the timeout is not dependent on volume sequence numbers, or 
                  clock time, but a count of volume starts. */
 
	       /* first, check the process status for the product,
	          assume generation is always the zeroth instance */
               status = ORPGMGR_get_task_status( ORPGPAT_get_gen_task(this_entry->request.prod_id),
	                                         0, &task_status);
	       if (status <0)
	          error_flag = OTR_TASK_FAILED;

	       else{

	          if (task_status == MRPG_PS_ACTIVE)
	             error_flag = OTR_PRODUCT_NOT_AVAILABLE;
	           
	          else if (task_status == MRPG_PS_NOT_STARTED)
	             error_flag = OTR_TASK_NOT_STARTED;

	          else
	             error_flag = OTR_TASK_FAILED;
	             
	       }          

	       OTR_reply_to_request( this_entry->server_id, &(this_entry->request), 
                                     &(this_entry->header), 0, this_entry->request.prod_id,
                                     0, error_flag, 1);

	       this_entry = release_from_list(this_entry);

            } 
            else {

               /* If this product has elevation parameter and represents a multiple
                  elevation request, decompose the request according to the current 
                  vcp in operation. */
               if( elev_flag_req ){

                  int num_elevs = 0;
                  int vs_num;
                  short vcp_elev_angles[ MAX_ELEVATION_CUTS];

                  vs_num = Vol_number_in_rda_stat % MAX_VSCAN;
                  if( vs_num == 0 )
                     vs_num = MAX_VSCAN;

                  if( (num_elevs = ORPGPRQ_get_requested_elevations( (int) Cr_gsm.vcp, 
                                                          this_entry->request.params[elev_param],
                                                          (int) MAX_ELEVATION_CUTS, vs_num, 
                                                          vcp_elev_angles, NULL )) > 0 ){

                     int i;

                     /* Allocate temporary storage for this product request for this elevation. */
                     Pd_request_products *this_request_ptr = 
                                 (Pd_request_products *) calloc( 1, sizeof(Pd_request_products) );

                     if( this_request_ptr == NULL ){

                        LE_send_msg( GL_MEMORY, "Memory Allocation Failed for %d Bytes \n",
                                     sizeof(Pd_request_products) );
                        ORPGTASK_exit(GL_MEMORY);

                     }
  
                     /* Do for each elevation ... */
                     for( i = 0; i < num_elevs; i++ ){
               
                        int made_request = REALTIME_REQUEST;

                        /* Copy this request to temporary storage.  This needs to be done
                           inside the loop since the "num_products" field is decremented 
                           by call to OTR_add_to_volume_requests(). */
                        memcpy( this_request_ptr, &this_entry->request, 
                                sizeof(Pd_request_products) );

                        /* Set the number of products to 1 for this request .... if original
                           request number of products is greater than 1, this will be taken 
                           care of by the request with the elevation flag set parameter. */
                           this_request_ptr->num_products = 1;

                        /* Set the elevation parameter. */
                        this_request_ptr->params[elev_param] = vcp_elev_angles[i];

                        /* Add the request to real-time request list.  Set the volume
                           number for the request to the volume number read from Volume
                           Status (i.e., Vol_number_in_rda_stat) so that this request is
                           satisfied with the current volume scan's product. */
                        OTR_add_request_to_request_list( this_entry->server_id, 
                                       &this_entry->header, this_request_ptr, 0, 
                                       &made_request, Vol_number_in_rda_stat );

                     }

                     free( this_request_ptr ); 

                  }

               }

               /* Go to next entry in real-time list. */
	       this_entry = this_entry->next;

	    }

         }

      }
      else
         this_entry = this_entry->next;
	
    }

    /* send the updated message to the scheduler */
    Post_realtime_request();

} /* End of OTR_new_volume_product_requests() */

/**************************************************************************
   Description:  To be called when the ORPGDAT_PROD_STATUS changes. 
      It reads in the current product status.  If any requests were fulfilled by
      a product that has become ready, a reply message is sent to the proper p_server.
   Input: product status lb
   Output: Replies via OTR_reply to request
   Returns: void
   Globals: Request_list_first
   Notes:
**************************************************************************/
void OTR_product_status_update(){

    int             status;			/* status of lb operations */
    Prod_gen_status_header *product_status;	/* pointer to status message
						 * header */
    Prod_gen_status *prod_status_array;		/* pointer to product status in
					 	 * message */
    Table_list     *this_entry;			/* current entry in request list being
				 		 * checked for action */
    int             last_flag;			/* set to one when this is the last message
				 		 * to fulfill the request */
    int             i;				/* index for loops */
    int             error_flag;			/* set to status of reply */
    unsigned int    message_id;			/* message number that fulfills the 
						 * requests */
    int             request_deleted = 0;	/* indicates a request from
						 * the list was deleted and a
						 * new message should be sent
						 * to ps_routine */
    int             vol_depth = 0;		/* The number of volumes in product status.
						   Limited to PGS_LIST_LENGTH */
    int             ivol_index = 0;

    /* if there were no requests, then just return */
    if (Request_list_first == NULL) {
	return;
    }

    status = ORPGDA_read(ORPGDAT_PROD_STATUS, (char *) &product_status, LB_ALLOC_BUF, 
                         PROD_STATUS_MSG);
    if (status < 0) {

	/* can't read status, so just release memory and return */
        LE_send_msg( GL_ERROR, "Error Reading Product Status (%d)\n", status );
	return;

    }

    Vol_number_in_prod_stat = product_status->vnum[0];  /* save for replay requests and scheduling*/    
    vol_depth = product_status->vdepth;

    prod_status_array = (Prod_gen_status *) ((char *) product_status +
			      ALIGNED_SIZE(sizeof(Prod_gen_status_header)));

    /* look through all the request on the list */
    this_entry = Request_list_first;
    while (this_entry != NULL) {

        if( ((this_entry->request_made == REALTIME_REQUEST) 
                                   &&
	    (this_entry->requested_for_this_volume <=  product_status->vnum[0]))  
                                   ||
	    (this_entry->request.seq_number == ALERT_PAIRED_PRODUCT_SEQUENCE_NUMBER))   {
	   	    
            /* set the last entry flag if this is the last product */
	    if (this_entry->product_counter == 1) {
		last_flag = 1;
	    } else {
		last_flag = 0;
	    }

            /* initialize the message_id so the default is that the product is not scheduled */
            message_id = PGS_NOT_SCHEDULED;

	    /*
	     * now look through the product status for the same product
	     * requested
	     */

	    for (i = 0; i < product_status->length; i++) {
		if (this_entry->request.prod_id == prod_status_array[i].prod_id) {

		    if (0 != OTR_compare_parameters(this_entry->request.params, prod_status_array[i].params,
					     this_entry->request.prod_id)) {

			/* send a reply to product distribution */
			if ((this_entry->request.seq_number == ALERT_PAIRED_PRODUCT_SEQUENCE_NUMBER) &&
			     ((this_entry->request_made == ALERT_SCHEDULED) ||
			      (this_entry->request_made == REPLAY_REQUEST_MADE))){

			          for (ivol_index = 0; ivol_index<2; ivol_index++){

			             if (product_status->vnum[ivol_index] == this_entry->request.VS_start_time) {

			                 message_id = prod_status_array[i].msg_ids[ivol_index];
			                 LE_send_msg(GL_INFO | LE_VL3, 
			                      "Alert product %d message status or number %d within timeout \n",
			                      this_entry->request.prod_id, message_id);
			                 break;

			             }

			          }
			     
			} else {

			   message_id = prod_status_array[i].msg_ids[0];

                           /* If the message_id is invalid (indicating the product was not generated),
                              check previous volume scans for valid product. */
			   if( (message_id >= LB_MAX_ID) && (this_entry->request_made == REALTIME_REQUEST)) {

			      for (ivol_index = 0; ivol_index < vol_depth; ivol_index++ ){

			         if(this_entry->requested_for_this_volume > product_status->vnum[ivol_index]) 
			            break;

                                 /* If the message ID is a valid ID, then the product was generated. */
			         if( prod_status_array[i].msg_ids[ivol_index] < LB_MAX_ID ){ 

				    message_id = prod_status_array[i].msg_ids[ivol_index];
				    break;

			         }

			      }

			   }

			}

			if (message_id == PGS_SCHEDULED) {
			    /*
			     * product is not ready yet, but it has been
			     * scheduled
			     */
			     
			} else if ((message_id == PGS_REQED_NOT_SCHED) || 
			           (message_id == PGS_NOT_SCHEDULED)   ||
			           (message_id == PGS_VOLUME_ABORTED) ) {
			    /*
			     * request got in, but the product is not
			     * scheduled for this volume (this may happen if
			     * the product is not produced in this weather
			     * mode or a change in VCP changes angles for schedule) or its a free text
			     * message which cannot be scheduled
			     */
			    LE_send_msg(GL_INFO | LE_VL3, " product %d requested but not scheduled (message ID: %d)\n",
					    this_entry->request.prod_id, message_id);
			    LE_send_msg(GL_INFO | LE_VL3, " -->Request parameters: %d %d %d %d %d %d\n",
					    this_entry->request.params[0], this_entry->request.params[1],
					    this_entry->request.params[2], this_entry->request.params[3],
					    this_entry->request.params[4], this_entry->request.params[5] );
			    
			} else {
			    if (message_id < LB_MAX_ID) {
				/* we have a good product status */
				error_flag = OTR_PRODUCT_READY;
			    } else if (message_id == PGS_TASK_NOT_RUNNING) {
				error_flag = OTR_TASK_NOT_RUNNING;
			    } else if (message_id == PGS_TASK_FAILED) {
			        error_flag = OTR_TASK_FAILED;
			    } else if (message_id == PGS_TASK_SELF_TERM) {
			        error_flag = OTR_TASK_SELF_TERM;
			    } else if (message_id == PGS_SLOT_UNAVAILABLE) {
			        error_flag = OTR_SLOT_FULL;
			    } else if (message_id == PGS_INVALID_PARAMS) {
			        error_flag = OTR_INVALID_PARAMS;
			    } else if (message_id == PGS_MEMORY_LOADSHED) {
			        error_flag = OTR_MEM_LOADSHED;
			    } else if (message_id == PGS_DISABLED_MOMENT) {
				error_flag = OTR_DISABLED_MOMENT;
			    } else if (message_id == PGS_DATA_SEQ_ERROR) {
				error_flag = OTR_DATA_SEQ_ERROR;
			    } else if (message_id == PGS_PRODUCT_NOT_GEN) {
				error_flag = OTR_PRODUCT_NOT_GEN;
			    } else {

				/* some other error happened */
				error_flag = OTR_VOLUME_ABORTED;
			    }

			    
			    LE_send_msg(GL_INFO | LE_VL2, 
                                   "Found Prod for Current Prod Request, prod %d, msg_id %d \n",
				   this_entry->request.prod_id, message_id);
			    
			    OTR_reply_to_request(this_entry->server_id,
						 &(this_entry->request),
						 &(this_entry->header),
						 product_status->vnum[0],
						 this_entry->request.prod_id,
						 (int) message_id,
						 error_flag,
						 last_flag);
			    /*
			     * update the counters/indicators in this request
			     * on the list
			     */
			    this_entry->product_counter--;
			    this_entry->interval_counter = this_entry->request.req_interval;
			    this_entry->requested_for_this_volume += this_entry->request.req_interval;
			    break;	/* no need to check any more products
					 * for this request */

			}
		    }
		}
	    }
	}
	if (this_entry->product_counter <= 0) {
	    /*
	     * no more products for this request - release this entry from
	     * list
	     */
	    this_entry = release_from_list(this_entry);
	    request_deleted = 1;
	} else {
	    this_entry = this_entry->next;
	}
    }
    free((void *) product_status);
    if (request_deleted != 0)
       Post_realtime_request();

}

/**************************************************************************

   Description:
      Post real-time, one-time request. 

   Inputs:
      request - the request data.
      new_entry - the entry in Table_list corresponding to request.
      made_request - flag indicating whether or not request already made.

   Outputs:

   Returns:
      void

   Notes:

**************************************************************************/
void OTR_post_realtime_onetime_request( int p_server_id, 
                                        Pd_request_products *request,
                                        void *entry ){

   Table_list *new_entry = (Table_list *) entry;

   /* schedule realtime request if it has not already been scheduled */
   if( (0 != add_request_to_realtime_message(request, new_entry)) ){

      LE_send_msg( GL_INFO | LE_VL3, "^^^Send Real-time Request (Product Server %d)\n",
                   p_server_id );
      ORPGDA_write( ORPGDAT_RT_REQUEST, (char *) Current_request_message,
                    Realtime_list_size, OTR_PSERVER_NUMBER );
      EN_post(ORPGEVT_OT_SCHEDULE_LIST, 0, 0, 0);
        
   }

}


/**************************************************************************
   Description: local routine to remove a request entry from the request list.
   Input: Pointer to the entry to be released.
   Output: none
   Returns: Pointer to the next entry after the one deleted.
   Globals: Request_list_first
   Notes:
**************************************************************************/
Table_list* release_from_list(Table_list * pointer){

    Table_list     *release;	/* the list element that should be released
				 * back to the heap */

    
    LE_send_msg(GL_INFO | LE_VL3, "releasing request from list \n");
    
    /* set the previous entry's next, to this pointer's next */
    if (pointer->prev != NULL) {
	((Table_list *) (pointer->prev))->next = pointer->next;
    } else {			/* i.e. this is the first entry in the list */
	Request_list_first = pointer->next;
    }

    /* set the next entry's previous to this entry's previous */
    if (pointer->next != NULL) {
	((Table_list *) (pointer->next))->prev = pointer->prev;
    }

    /* now release the entry to the heap, and point to the next entry */
    release = pointer;
    pointer = pointer->next;
    free((void *)release);

    return (pointer);

}

/**************************************************************************
   Description: Rebuilds the realtime request message.  This should be used after
      removing a request, as the request may or may not be duplicated
      elsewhere in the list.

   Input: none

   Output: none

   Returns: none

   Globals: Realtime_list_size, Current_request_message, Request_list_first, Current_request_number

   Notes:
**************************************************************************/
void rebuild_request_message(){

    Table_list     *this_entry;

    LE_send_msg(GL_INFO | LE_VL3, "Rebuilding request message \n");
    
    Realtime_list_size = sizeof(Pd_msg_header);
    Current_request_message = (Routine_product_request *) 
                            realloc((void *) Current_request_message, Realtime_list_size);

    /* initialize the header for the message */
    Current_request_message->routine_product_header.src_id = -1;	/* -1 is ps onetime user */
    Current_request_message->routine_product_header.dest_id = -1;
    Current_request_message->routine_product_header.n_blocks = 1;
    Current_request_message->routine_product_header.length = Realtime_list_size;
    Current_request_message->routine_product_header.line_ind = -1;	/* -1 is ps onetime user */

    this_entry = Request_list_first ;
    Current_request_number = 0;
    while (this_entry != NULL) {
    
        /* schedule products 1 volume early to ensure that no timing problems
         * between here and ps_routine cause omission of product in the correct
         * volume.  i.e. ps_routine schedules products after a start-of-volume too,
         * so if it receives this message too late for first elevation, the product
         * might not get scheduled until the next volume.
         */
        if (this_entry->requested_for_this_volume <= (Vol_number_in_rda_stat+1)){        
	    add_request_to_realtime_message( &(this_entry->request), this_entry );
	}
	else{
	    LE_send_msg(GL_INFO | LE_VL3, "Product %d will not be scheduled till volume %d\n",
	         this_entry->request.prod_id, this_entry->requested_for_this_volume  );
	}	

	this_entry = this_entry->next;
    }

}

/**************************************************************************
   Description: local routine to add a request to the product message
      to be sent to the real time product scheduler.
   Input: The request to be added to the list.
   Output: none
   Returns: 1 if the updated product list needs to be sent to the scheduler,
            0 if this is a duplicate request and the list does not need to be sent out.
   Globals: Current_request_number, Realtime_list_size, Current_request_message
   Notes:
**************************************************************************/
int add_request_to_realtime_message( Pd_request_products *request, 
                                     Table_list *this_entry ){

    int             already_done;	/* indicates this is a duplicate of a
					 * request already submitted */
    int             i;		/* index for search loop */

    LE_send_msg(GL_INFO | LE_VL3, "Adding a Request to the Real-Time List \n");
    
    already_done = 0;
    if (Current_request_number > 0) {

	for (i = 0; ((i < Current_request_number) && (already_done == 0)); i++) {

	    if ((Current_request_message->routine_request[i].prod_id == request->prod_id) &&
		(0 != OTR_compare_parameters(Current_request_message->routine_request[i].params,
				      request->params, request->prod_id))) {

		already_done = 1;

                LE_send_msg( GL_INFO | LE_VL3, "--->Request Already in Real-Time List\n" );
		break;		/* don't need to check any more, this request
				 * has already been made */

	    }
	}
    }

    if (already_done == 0) {

	/* now add it to the list that is sent to product scheduler */
	if (Current_request_message == NULL) {

	    Realtime_list_size = sizeof(Pd_msg_header);
	    Current_request_message = (Routine_product_request *) 
                                    realloc((void *) Current_request_message, Realtime_list_size);
	    /* initialize the header for the message */
	    Current_request_message->routine_product_header.src_id = -1;	/* -1 is ps onetime user */
	    Current_request_message->routine_product_header.dest_id = -1;
	    Current_request_message->routine_product_header.n_blocks = 1;	/* first block in the
										 * request */
	    Current_request_message->routine_product_header.line_ind = -1;	/* -1 is ps onetime user */
	}

	Realtime_list_size += sizeof(Pd_request_products);
	Current_request_message = (Routine_product_request *) 
                        realloc((void *) Current_request_message, (size_t) Realtime_list_size);
	if (Current_request_message == NULL) {
	    LE_send_msg(GL_MEMORY | LE_VL0, "memory allocation failed in add_request_to_realtime_message \n");
	    ORPGTASK_exit(GL_MEMORY);
	}

	Current_request_message->routine_request[Current_request_number] = *request;
	Current_request_message->routine_product_header.n_blocks++;
	Current_request_message->routine_product_header.length = Realtime_list_size;
	Current_request_number++;

        LE_send_msg( GL_INFO | LE_VL3, "--->Product %d Added to Real-Time List\n",
                     request->prod_id );
        LE_send_msg( GL_INFO | LE_VL3, "------>Num Products: %d, Product Counter: %d\n",
                     request->num_products, this_entry->product_counter );
        LE_send_msg( GL_INFO | LE_VL3, "------>Params: %6d %6d %6d %6d %6d %6d\n",
                     request->params[0], request->params[1], request->params[2],
                     request->params[3], request->params[4], request->params[5] );
	return (1);
    }
    return (0);
}

/**************************************************************************

   Description: This function checks whether two product dependent
      parameter arrays are identical. A special check is done for products
      with an elevation parameter.  For these products, the parameters are
      equal if the elevation index is the same (i.e. They are considered the
      same elevation if they are closest to the same elevation cut in the
      current volume scan).  We ignore the failure
      condition of get_elevation_index because it should
      not happen.

   Inputs:	params1 - the first product parameter array.
                params2 - the second product parameter array.
                prod_id - the product id.

   Return:	0 if the two parameter array are different or
                non-zero if they are considered equivalent.

   **************************************************************************/
int OTR_compare_parameters(short *params1, short *params2, short prod_id){

   int             ep_ind;	/* elevation parameter index */
   int             i;	        /* index for loop to check parameters */
   int             m;          /* param subscript to check */
 
   ep_ind = get_elev_param_index((int) prod_id);
   if( ep_ind >= 0 ){

      /* If either elevation parameter contains elevation
         flag bits, then the 2 must match on value. */
      if( (params1[ep_ind] & ORPGPRQ_ELEV_FLAG_BITS) 
                          ||
          (params2[ep_ind] & ORPGPRQ_ELEV_FLAG_BITS) ){

         if( params1[ep_ind] != params2[ep_ind] )
            return (0);

      }

      /* Do a match on elevation index. */
      if( get_elevation_index((int) params1[ep_ind]) !=
          get_elevation_index((int) params2[ep_ind]))
         return (0);

   }

   for (i = 0; i < ORPGPAT_get_num_parameters(prod_id); i++){

      m = ORPGPAT_get_parameter_index (prod_id, i);
      if ((m != ep_ind) &&
	  (params1[m] != PARAM_ANY_VALUE) &&
	  (params2[m] != PARAM_ANY_VALUE) &&
	  (params1[m] != PARAM_UNUSED) &&
	  (params2[m] != PARAM_UNUSED) &&
	  (params1[m] != params2[m]))
         return (0);

   } 
      
   return (1);

}

/**************************************************************************

   Description: This function returns the elevation value in the product
                parameter array "param".

   Inputs:	prod_id - product id;

   Return:	The elevation parameter index on success or 
                -1 if the product does not have an elevation parameter.

**************************************************************************/
int get_elev_param_index(int prod_id){

    int             ind;	/* elevation index */

    /* the elevation parameter index */
    if (prod_id >= 0){
	ind = (int) ORPGPAT_elevation_based(prod_id);
        if( ind < 0 )
           ind = -1;

    }
    else
	ind = -1;

    return (ind);
}

/**************************************************************************

   Description: This function returns the elevation index (starting with 1)
                that has nearest elevation to "elev".

   Input:	elev - the elevation angle in .1 degrees.

   Output:	none

   Return:	Returns the elevation index on success or 0 on failure.

**************************************************************************/
int get_elevation_index(int elev){

    int             mind;	/* minimum difference between input elevation
				 * and the elevations in the volume */
    int             i;		/* index to loop though all elevations in the
				 * volume scan */
    int             diff;	/* difference between input elevation and the
				 * elevations in the volume */
    int             min=0;	/* index to the elevation where "mind" was
				 * found */

    /*
     * if there's no status, just return the elevation, this allows matches
     * if they are both the same, but no GSM has been read yet.
     */
    if (Cr_gsm.n_elev == 0)
	return (elev);
    mind = -1;
    for (i = 0; i < Cr_gsm.n_elev; i++) {
	diff = elev - Cr_gsm.elev_angle[i];
	if (diff < 0)
	    diff = -diff;
	if (mind == -1 || diff < min) {
	    min = diff;
	    mind = i;
	}
    }
    if (mind >= 0)
	return (mind + 1);
    else
	return (0);
    
}

/**************************************************************************

   Description: This function adds a request to the message for the replay task,
                along with requests for all the products that the request depends
                upon.
                
                Note that this function is NOT reentrant (because of the
                Replay_request_message global static variable), but IS recursive.

   Input:	pointer to a request structure

   Output:	replay scheduling message is updated.

   Return:	none

**************************************************************************/
void add_request_to_replay_message(Pd_request_products * request){

    Prod_request  *replay_request; /* pointer to last request */
    int ep_ind; /* elevation index parameter subscript */
    int add_request = 1;  /* set to zero if duplicate request */
    Pd_request_products dependent_product_request;
    int number_of_dependent_products;
    int i;
    
    add_request = 1;
    if (Replay_request_message != NULL){
        /* if product is already in the message, don't add it */
        replay_request = Replay_request_message;
        while ((replay_request->pid != -1) && (add_request == 1)){
            if (replay_request->pid == request->prod_id &&
                    replay_request->param_1 == request->params[0] &&
                    replay_request->param_2 == request->params[1] &&
                    replay_request->param_3 == request->params[2] &&
                    replay_request->param_4 == request->params[3] &&
                    replay_request->param_5 == request->params[4] &&
                    replay_request->param_6 == request->params[5]) {
                add_request = 0; /* duplicate request, don't add to list */
                LE_send_msg(GL_INFO | LE_VL3, 
                            "replay pid %d request was a duplicate \n",
                            request->prod_id);
             }
             replay_request++;
        }
             
    }
    if (add_request == 1){
        /* first add requests for all the products this one depends on */
        
        number_of_dependent_products = ORPGPAT_get_num_dep_prods(request->prod_id);
	
	LE_send_msg (GL_INFO | LE_VL3, "check dep on product %d, get %d \n", 
	         request->prod_id, 
		 number_of_dependent_products);
		
        if (number_of_dependent_products > 0){
        
            /* set the parameters for the dependent request the same as the parent*/
            LE_send_msg(GL_INFO | LE_VL3, "request has dependent products \n");
            
            dependent_product_request = *request;
            for(i=0; i < number_of_dependent_products; i++){
                dependent_product_request.prod_id = ORPGPAT_get_dep_prod(request->prod_id, i);
                if ((dependent_product_request.prod_id != ORPGPAT_ERROR)  &&
                    (ORPGPAT_get_warehoused (dependent_product_request.prod_id) ==0 )) {
                
                    /* NOTE THIS IS A RECURSIVE ROUTINE */
                    add_request_to_replay_message(&dependent_product_request);
                }
            }
            
        }
        /* all the products this depends on have been added to the request
         * now add this one
         */
        
        Current_replay_number++;
        Replay_request_message = (Prod_request *)realloc((char *)Replay_request_message, 
                                         (Current_replay_number+1)*sizeof(Prod_request));
        replay_request = Replay_request_message + (Current_replay_number - 1);
        replay_request->pid = request->prod_id;
        replay_request->param_1 = request->params[0];
        replay_request->param_2 = request->params[1];
        replay_request->param_3 = request->params[2];
        replay_request->param_4 = request->params[3];
        replay_request->param_5 = request->params[4];
        replay_request->param_6 = request->params[5];
        
        ep_ind = get_elev_param_index(request->prod_id);
        if (ep_ind == -1){
            replay_request->elev_ind = -1;
        }
        else{
            replay_request->elev_ind = get_elevation_index(request->params[ep_ind]);
        }
        replay_request->req_num = request->seq_number;
        if (request->flag_bits & ALERT_SCHEDULING_BIT){
            replay_request->vol_seq_num = request->VS_start_time;
            replay_request->type = ALERT_OT_REQUEST;
        }
        else{
            replay_request->type = USER_OT_REQUEST;
            replay_request->vol_seq_num = Vol_number_in_prod_stat;
        }
        LE_send_msg(GL_INFO | LE_VL3, 
            "add request from replay for pid %d elev %d params %d %d %d %d %d %d\n",
            request->prod_id, replay_request->elev_ind,
            replay_request->param_1, replay_request->param_2,
            replay_request->param_3, replay_request->param_4,
            replay_request->param_5, replay_request->param_6);


        replay_request++; /* point to next structure */
        replay_request->pid = -1; /* indicate end of message */
        
    }	       
    return;

}

/**************************************************************************

   Description: This function sends the built up request message to the replay task.

   Input:	none

   Output:	via subroutine

   Return:	none

**************************************************************************/
void send_replay_message(){

   LE_send_msg(GL_INFO | LE_VL2, "request being sent to replay\n");

   ORPGDA_write(ORPGDAT_REPLAY_REQUESTS,(char *)Replay_request_message, 
             ((Current_replay_number+1)*sizeof(Prod_request)),
             LB_NEXT);
   free ((void *)Replay_request_message);
   Replay_request_message= NULL;
   Current_replay_number= 0;
   return;

}

/**************************************************************************

   Description: This function builds and sends the request message to the replay task.

   Input:	none

   Output:	none

   Return:	none

   **************************************************************************/
void build_and_send_new_replay_message(){

              Table_list     *new_request = NULL;
              Table_list     *pointer = NULL;
              int             ep_ind_new; /* elevation index for new request */
	      int             new_elevation; /* elevation of new requests */
	      int             check_elevation; /* elevation of candidates */
              
              
	    /* 
	     * search for the next requests to send,
	     * which will be the oldest, highest priority request
	     * which has not already been made.  Alert paired product
	     * requests are highest priority, followed by those with
	     * the high priority bit set.
	     */
	     
	     pointer = Request_list_first;
	     while (pointer != NULL) {	         
	         if (pointer->request_made == NO_REQUESTS){
                     if ((new_request == NULL) ||
	                (((pointer->request.flag_bits & ALERT_SCHEDULING_BIT) >=
	                 (new_request->request.flag_bits & ALERT_SCHEDULING_BIT)) ||
	                ((pointer->request.flag_bits & PRIORITY_FLAG_BIT) >=
	                 (new_request->request.flag_bits & PRIORITY_FLAG_BIT )))){
	                 
	                    new_request = pointer;
	             }
	          }
	          pointer = pointer->next;
	     }
	     
	     if (new_request != NULL) {
	         LE_send_msg(GL_INFO | LE_VL3, "building new requests for replay \n");
	         
	         /* highest priority, oldest request now in new_request */
	         /* find this request's elevation parameter */
	         
	         ep_ind_new = get_elev_param_index(new_request->request.prod_id);
	         if (ep_ind_new == -1){
	             new_elevation = -1;
	         }
	         else{
	             new_elevation = new_request->request.params[ep_ind_new];
	         }
	         /* now find all requests for same elevation, and add
	          * them to the message.
	          */
	         pointer = Request_list_first;
	         while (pointer != NULL) {
	             if (pointer->request_made == NO_REQUESTS){
	                  ep_ind_new = get_elev_param_index(pointer->request.prod_id);
	                  if (ep_ind_new == -1){
	                       check_elevation = -1;
	                  }
	                  else{
	                       check_elevation = new_request->request.params[ep_ind_new];
	                  }
	                  if (new_elevation  == check_elevation){
	             
	                      /* this is the same elevation, add to request list */
	                      add_request_to_replay_message(&(pointer->request));
	                      pointer->request_made = REPLAY_REQUEST_MADE;	               
	                   }
	              }
	              pointer = pointer->next;
	         }
	         /* all requests are now in the message, send it */
	         LE_send_msg(GL_INFO | LE_VL3, "sending new replay request \n");
	     
	         send_replay_message();
	    }	      
    
}

/**************************************************************************
   Description: Initializes the elevation data to enable the finding of
                products with the same elevation index.  This routine
                should be called at ps_onetime initialization, and whenever
                the elevation data changes afterwards.
   Input: none
   Output: none
   Returns: none
   Globals: Realtime_list_size, Current_request_message, Request_list_first, Current_request_number
            Cr_gsm
   Notes:
   **************************************************************************/
void OTR_update_elevation_data(){

    int status;        /* status of read from the general status message */
    Vol_stat_gsm_t vol;/* volume scan data */
    int ind;
    int n_elev;        /* number of elevations */
    int i;             /* index for loops */
    

    status = ORPGDA_read(ORPGDAT_GSM_DATA, (char *) &vol,
			 sizeof(Vol_stat_gsm_t), VOL_STAT_GSM_ID);
    if (status != sizeof(Vol_stat_gsm_t)) {
	LE_send_msg(GL_INFO | LE_VL1,
	"ORPGDA_read failed (ORPGDAT_GSM_DATA, VOL_STAT_GSM_ID) (status %d)",
		    status);
	/* simulate a blank volume scan read */
	vol.num_elev_cuts= 0;	    
    } 
    else{
       Vol_number_in_rda_stat=vol.volume_number;
       last_volume_time = (long)( vol.cv_time/1000); /* set global time */
    }
    /*
     * update elevation information (this is used when checking for
     * elevation parameters being equal)
     */
    ind = -1;
    n_elev = 0;
    for (i = 0; i < vol.num_elev_cuts; i++) {

	if (ind == vol.elev_index[i])
	    continue;
	if (n_elev >= MAX_GS_N_ELEV) {
	    LE_send_msg(GL_INFO | LE_VL1,
			"Too many elevations (%d) found in VOL_STAT_GSM_ID", n_elev);
	    break;
	}

	/* copy elevation info to the current general status message */
	ind = vol.elev_index[i];
	Cr_gsm.elev_angle[n_elev] = vol.elevations[i];
	n_elev++;
    }

    /* blank out unused elevations */
    Cr_gsm.n_elev = n_elev;
    for (i = n_elev; i < MAX_GS_N_ELEV; i++)
	Cr_gsm.elev_angle[i] = 0;

    Cr_gsm.vcp = vol.vol_cov_patt;

}

/***********************************************************************************

   Description:
      Writes the real-time request to LB and posts event.

   Inputs:

   Outputs:

   Returns:

   Notes:

**********************************************************************************/
void Post_realtime_request(){

   rebuild_request_message();
   ORPGDA_write( ORPGDAT_RT_REQUEST, (char *) Current_request_message,
		 Realtime_list_size, OTR_PSERVER_NUMBER );
   EN_post(ORPGEVT_OT_SCHEDULE_LIST, 0, 0, 0);

}
