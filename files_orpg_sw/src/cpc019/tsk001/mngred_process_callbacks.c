/********************************************************************************

            file:  mngred_process_callbacks.c

     Description:  This file contains all the callback routines that are 
                   registered for LB notification. Any LB message that
                   the redundant manager is interested in when it is updated
                   has been registered for callback.

 ********************************************************************************/

/*
 * RCS info
 * $Author: steves $
 * $Locker:  $
 * $Date: 2013/05/14 20:58:34 $
 * $Id: mngred_process_callbacks.c,v 1.13 2013/05/14 20:58:34 steves Exp $
 * $Revision: 1.13 $
 * $State: Exp $
 */

#include <sys/types.h>
#include <time.h>

#include <mngred_globals.h>
#include <mrpg.h>
#include <orpgsite.h>


#define SAILS_DISABLED       0    /* SAILS is disabled */
#define SAILS_ENABLED        1    /* SAILS is enabled */


    /* file scope variables */

static Channel_status_t Redundant_channel_status;


/********************************************************************************

    Description: This routine is the callback routine for Adaptation Data LB 
                 updates. The updated LB message is flagged here in the LB
                 lookup table so the other channel will be updated with
                 the message (the actual redundant channel update is performed 
                 later).

          Input: lbd     - the descriptor of the lb that initiated the callback
                 msgid   - the id of the message that was updated
                 msg_len - the length of the message
                 dataid  - the datastore id of the lb that initiated the 
                           callback

         Output:

         Return:

        Globals: CHAnnel_link_state       - see mngred_globals.h & orpgred.h
                 CHAnnel_state            - see mngred_globals.h & orpgred.h
                 CHAnnel_status           - see mngred_globals.h & orpgred.h
                 Redundant_channel_status - see file scope global section
 
          Notes:
 
 ********************************************************************************/

void PC_process_adapt_dat_update_event (int lbd, LB_id_t msgid, int msg_len, 
                                        void *dataid)
{
   int  ret;           /* return value from function calls */
   int  data_id;       /* the data id type cast back to an int */
   int lb_update_type; /* type of update to perform */
   int sender_id;      /* id of the sender that initiated the callback */ 
   Channel_status_t redun_chanl_status; /* redundant channel status msg */


      /* read the redundant channel status msg */

   ret = ORPGDA_read (ORPGDAT_REDMGR_CHAN_MSGS, (char *) &redun_chanl_status,
                      sizeof (Channel_status_t), ORPGRED_REDUN_CHANL_STATUS_MSG);

      /* if a read error occurs, set the redundant channel link state to
         "down" */

   if (ret < 0)
   {
      redun_chanl_status.rpg_rpg_link_state = ORPGRED_CHANNEL_LINK_DOWN;
      LE_send_msg (GL_ERROR, 
                   "Error reading the redundant channel status msg (err: %d)",
                   ret);
   }

   data_id = (int) dataid;  /* cast the data_id back to an int */

      /* get the id of the sender that initiated the callback */

   sender_id = LB_NTF_sender_id ();

      /* do not process the callback if the sender of the data is the
         other channel. We are only interested in updates generated by
         this channel. */

   if ( redun_chanl_status.rpg_channel_number == sender_id)
   {
      LE_send_msg (MNGRED_DEBUG_VL, 
         "Redundant channel updated the Adapt Dat (data_id: %d,  msg_id: %d, sender id: %d)",
         data_id, msgid, sender_id);
      return;
   }

   LE_send_msg (MNGRED_DEBUG_VL, "Adapt dat update event received");
   LE_send_msg (MNGRED_DEBUG_VL, "        lb_id:     %d", data_id);
   LE_send_msg (MNGRED_DEBUG_VL, "       msg_id:     %d", msgid);
   LE_send_msg (MNGRED_DEBUG_VL, "    sender_id:     %d", sender_id);

      /* if this channel is inactive, update the Adaptation Data
         update time then return */

   if (CHAnnel_state == ORPGRED_CHANNEL_INACTIVE)
   {
      CHAnnel_status.adapt_dat_update_time = time (NULL);
      return;
   }

      /* check the Adapt Dat time stamps to ensure they're in sync and check
         the RPG/RPG link state on both channels to ensure both have detected
         the link is up before allowing a single message update to re-sync the
         times. If it looks like an out-of-sync condition could occur,
         then perform a full update */

   if ((Redundant_channel_status.adapt_dat_update_time   != 
       CHAnnel_status.adapt_dat_update_time)             ||
      (CHAnnel_link_state == ORPGRED_CHANNEL_LINK_DOWN)  ||
      (redun_chanl_status.rpg_rpg_link_state == ORPGRED_CHANNEL_LINK_DOWN))
           lb_update_type = MNGRED_UPDATE_ALL_LBS;
   else
           lb_update_type = MNGRED_UPDATE_ONE_LB;

      /* update the Adaptation Data update time */

   CHAnnel_status.adapt_dat_update_time = time (NULL);

   ret = MLT_set_update_required_flag (data_id, 0, msgid, 
                                      lb_update_type, MNGRED_TRANSFER_ADAPT_DATA);

   WCD_set_adapt_data_updated_time ();

   if (ret == -1)
   {
      LE_send_msg (GL_ERROR, 
                "Error setting lookup table \"update required\" flag for data_id %d, msg_id %d",
                data_id, msgid);
               
      LE_send_msg (GL_STATUS | GL_ERROR, 
                   "Error updating redundant channel's Adaptation Data");
   }

   return;
}


/********************************************************************************

    Description: This routine is the callback routine for the LBs that are
                 updated at channel switchover.

          Input: lbd     - the descriptor of the lb that initiated the callback
                 msgid   - the id of the message that changed
                 msg_len - the length of the message
                 data_id - the datastore id of the lb that initiated the callback

         Output:

         Return:

        Globals:
 
          Notes: At the present, there are no LBs that are specifically updated 
                 because of a channel switchover. 
 
 ********************************************************************************/

void PC_process_at_switchover_event (int lbd, LB_id_t msgid, int msg_len, 
                                     void *data_id)
{
   /* there are no LBs updated at switchover at this time */
   return;
}


/********************************************************************************

    Description: This routine is the callback routine for the redundant manager
                 channel messages. All messages received are generated by the 
                 other channel.

          Input: lbd     - the descriptor of the lb that initiated the callback
                 msg_id  - the id of the message that changed
                 msg_len - the length of the message
                 data_id - the datastore id of the lb that initiated the callback

         Output:

         Return:

        Globals: CHAnnel_state            - see mngred_globals.h & orpgred.h
                 REDundant_channel_state  - see mngred_globals.h
                 Redundant_channel_status - see file scope global section
 
          Notes: The following redundant manager msg_ids are serviced by this 
                 routine (see orpgred.h for more info):
                 1. ORPGRED_REDUN_CHANL_STATUS_MSG
                 2. ORPGRED_PING_CHANNEL_LINK
                 3. ORPGRED_PING_RESPONSE
 
 ********************************************************************************/

void PC_process_channel_msg (int lbd, LB_id_t msg_id, int msg_len, void *data_id)
{
   Redundant_channel_msg_t channel_msg;  /* the ping msg to process */
   int ret_val;                          /* function calls return value */
   

   LE_send_msg (MNGRED_DEBUG_VL, "PC_process_channel_msg: msg_id %d", msg_id); 

      /* read the message if it is a ping msg */

   if (msg_id != ORPGRED_REDUN_CHANL_STATUS_MSG)
   {
      ret_val = ORPGDA_read ((int) data_id, &channel_msg, msg_len, msg_id);

      if (ret_val < 0)
      {
            LE_send_msg (GL_ERROR,
                   "ORPGDA error reading IPC channel message (err %d)",
                   ret_val);
            return;
      }
   }

      /* process the message received from the redundant channel */

   switch (msg_id)
   {
         /* process the "redundant channel status" message (ie. the 
            redundant channel sent its channel status to this channel) */

      case ORPGRED_REDUN_CHANL_STATUS_MSG:

         ret_val = ORPGDA_read ((int) data_id, &Redundant_channel_status, 
                                 msg_len, msg_id);

         if (ret_val < 0)
         {
            LE_send_msg (GL_ERROR,
              "Error in callback reading channel msg; msg_id %d; err %d...msg ignored...",
              msg_id, ret_val);
            return;
         }

            /* see if the redundant channel's channel_state changed */

         if (REDundant_channel_state !=
             Redundant_channel_status.rpg_channel_state)
         {
            char *redun_ch_state; /* ptr to the different redundant chanl states */

            if (Redundant_channel_status.rpg_channel_state == ORPGRED_CHANNEL_ACTIVE)
                redun_ch_state = "Active";
            else if (Redundant_channel_status.rpg_channel_state == 
                     ORPGRED_CHANNEL_INACTIVE)
                redun_ch_state = "Inactive";
            else
                redun_ch_state = "Unknown";
               
            LE_send_msg (GL_STATUS, "Redundant RPG channel state changed: %s",
                         redun_ch_state);
         }
         REDundant_channel_state = Redundant_channel_status.rpg_channel_state;

            /* if the rpg operability modes are in different states and this
               is the inactive channel, command this rpg to change modes */
         
         if ((CHAnnel_state == ORPGRED_CHANNEL_INACTIVE) &&
             (Redundant_channel_status.rpg_mode != CHAnnel_status.rpg_mode))
         {
            switch (Redundant_channel_status.rpg_mode)
            {
               case MRPG_TM_NONE: /* redundant chanl switched out of test mode */

                  ret_val = ORPGMGR_send_command (MRPG_EXIT_TM);
                  
                  if (ret_val < 0)
                     LE_send_msg (MNGRED_OP_VL, 
                              "Failure occurred commanding RPG out of Test Mode");
                  break;
                  
               case MRPG_TM_RPG: /* redundant chanl went into test mode */
               case MRPG_TM_RDA:
                  
                  ret_val = ORPGMGR_send_command (MRPG_ENTER_TM);
                  
                  if (ret_val < 0)
                     LE_send_msg (MNGRED_OP_VL, 
                              "Failure occurred commanding RPG into Test Mode");
                  break;

               default:
                  LE_send_msg (MNGRED_OP_VL, 
                    "Unsupported RPG Op Mode recv'd from the other channel (rpg_mode: %d)",
                    Redundant_channel_status.rpg_mode);
                  break;
            }
         }
               
         break;

            /* a ping was received from the redundant channel...send a ping 
               response back */

         case ORPGRED_PING_CHANNEL_LINK:

               /* echo the ping back to the redundant channel */
   
            ret_val = WCD_write_redundant_lb_data (ORPGDAT_REDMGR_CHAN_MSGS, 
                                    (char *) &channel_msg,
                                    sizeof (channel_msg),
                                    ORPGRED_PING_RESPONSE, NULL, NULL);

            if (ret_val < 0)
               LE_send_msg (GL_ERROR, 
                "Error writing ping response to redundant channel (seq #: %d)",
                 channel_msg.parameter1);
            else
               LE_send_msg (MNGRED_DEBUG_VL, 
                    "Ping response sent to redundant channel (seq #: %d)",
                    channel_msg.parameter1);

            break;

            /* a ping response was received from the redundant channel */

         case ORPGRED_PING_RESPONSE:
            CLS_update_ping_response (channel_msg.parameter1);
            break;

      default:
         LE_send_msg (GL_ERROR, 
                      "Invalid channel msg recv'd....msg ignored (msg id %d)",
                      msg_id);
         break;
   }

   return;
}


/********************************************************************************

    Description: This routine is the callback routine for the redundant manager
                 IPC channel commands. All commands are generated by the other 
                 channel's redundant manager.

          Input: lbd     - the descriptor of the lb that initiated the callback
                 msg_id  - the id of the message that changed
                 msg_len - the length of the message
                 data_id - the datastore id of the lb that initiated the callback

         Output:

         Return:

        Globals: CHAnnel_status          - see mngred_globals.h & orpgred.h
                 REDundant_channel_state - see mngred_globals.h
 
          Notes: The following redundant manager msg_ids are serviced by this 
                 routine (see orpgred.h for more info):
                 - ORPGRED_DNLOAD_CLUTTER_CENSOR_ZONES
                 - ORPGRED_SELECT_VCP
                 - ORPGRED_DOWNLOAD_VCP
                 - ORPGRED_UPDATE_ADAPT_DATA_TIME
                 - ORPGRED_UPDATE_SPOT_BLANKING
                 - ORPGRED_SEND_CHANNEL_STATUS
                 - ORPGRED_UPDATE_CMD
                 - ORPGRED_UPDATE_SR
                 - ORPGRED_UPDATE_AVSET
                 - ORPGRED_UPDATE_SAILS

 
 ********************************************************************************/

void PC_process_channel_cmd (int lbd, LB_id_t msg_id, int msg_len, void *data_id)
{
   Redundant_channel_msg_t channel_cmd; /* the channel command to process */
   int ret_val;                         /* function calls return value */

      /* read the channel command just received */

   ret_val = ORPGDA_read ((int) data_id, &channel_cmd, msg_len, msg_id);

   if (ret_val < 0)
   {
      LE_send_msg (GL_ERROR, 
                   "ORPGDA read error reading redun mgr channel command (err %d)",
                   ret_val);
      return;
   }

   LE_send_msg (MNGRED_TEST_VL, 
                "IPC command recieved from redundant channel, cmd %d", msg_id);

      /* process the channel command */

   switch (msg_id)
   {
      case ORPGRED_DNLOAD_CLUTTER_CENSOR_ZONES:/* dnld censor zones to RDA */
      case ORPGRED_SELECT_VCP:                 /* select a VCP */
      case ORPGRED_DOWNLOAD_VCP:               /* download a VCP */
      case ORPGRED_UPDATE_SPOT_BLANKING:       /* change spot blanking state */
      case ORPGRED_UPDATE_SR:                  /* change Super Res state */
      case ORPGRED_UPDATE_CMD:                 /* change CMD state */
      case ORPGRED_UPDATE_AVSET:               /* update AVSET selection */

            /* set the relevant command flags to service the command */

         DC_set_download_cmd (channel_cmd, msg_id);
      break;

      case ORPGRED_UPDATE_ADAPT_DATA_TIME: /* cmd to update this channel's 
                                              Adapt Data updated time */
         CHAnnel_status.adapt_dat_update_time = channel_cmd.parameter1;

         LE_send_msg (GL_STATUS, 
                      "Adaptation Data updated from redundant channel");

            /* send a status message to the redundant channel with the updated 
               Adaptation Data time */

         if (CST_transmit_channel_status () == -1)
             LE_send_msg (MNGRED_OP_VL, 
                   "Error sending channel status to redundant channel");
      break;
      
      case ORPGRED_UPDATE_SAILS: /* update SAILS selection */

            /* if this channel's and the redundant channel's SAILS states
               do not match, then update this channel's SAILS state */

         LE_send_msg (MNGRED_TEST_VL, "Update SAILS state cmd rec'd from other channel");

         if (channel_cmd.parameter1 != (int) ORPGINFO_is_sails_enabled())
         {
            switch (channel_cmd.parameter1)
            {
               case SAILS_DISABLED:

                  ret_val = ORPGINFO_clear_sails_enabled();

                  if (ret_val < 0)
                     LE_send_msg (MNGRED_OP_VL, "Error disabling SAILS");
               break;

               case SAILS_ENABLED:
                  ret_val = ORPGINFO_set_sails_enabled();

                  if (ret_val < 0)
                     LE_send_msg (MNGRED_OP_VL, "Error enabling SAILS");
               break;

               default:
                  LE_send_msg (MNGRED_OP_VL, 
                             "Unsupported SAILS IPC cmd setting received");
               break;
            }
         }

      break;
 
         /* other channel has commanded this channel to send its 
            channel status message */
                 
      case ORPGRED_SEND_CHANNEL_STATUS:

         if (CST_transmit_channel_status () == -1)
             LE_send_msg (MNGRED_OP_VL, 
                   "Error sending channel status to redundant channel");
      break;

      default:
         LE_send_msg (MNGRED_OP_VL, 
                      "Invalid IPC channel command rec'd(cmd %d)", msg_id);
      break;
   }
         
   return;
}


/********************************************************************************

    Description: This routine is the callback routine that sets the "update 
                 required" flag in the LB lookup table for State Data LB 
                 updates. State Data synchronization between the two channels
                 is managed by this routine (actual channel updates are 
                 performed later by another routine).

                  Also, the routine that sets the "update misc state data
                  required" flag is called here. This is to keep the misc state
                  data synchronized that is not updated via a LB callback routine.

          Input: lbd     - the descriptor of the lb that initiated the callback
                 msgid   - the id of the message that changed
                 msg_len - the length of the message
                 dataid  - the datastore id of the lb that initiated the callback

         Output:

         Return:

        Globals: CHAnnel_state - see mngred_globals.h & orpgred.h
 
          Notes:
 
 ********************************************************************************/

void PC_process_on_update_event (int lbd, LB_id_t msgid, int msg_len, 
                                 void *dataid)
{
   int  return_val; /* return value from function calls */
   int  data_id;    /* the data id type cast back to an int */


   data_id = (int) dataid;  /* cast the data_id back to an int */

      /* do not process the callback if this channel is not active */

   if (CHAnnel_state != ORPGRED_CHANNEL_ACTIVE) 
       return;

   LE_send_msg (MNGRED_DEBUG_VL, "\"On_Update\" callback rtn called");

      /* set the flag to update the misc state data */

   CST_set_misc_state_data_flag ();

      /* set the "update required" flag in the lookup table for this lb */

   return_val = MLT_set_update_required_flag (data_id, lbd, msgid, MNGRED_UPDATE_ONE_LB,
                                              MNGRED_TRANSFER_STATE_DATA);
   if (return_val == -1)                                              
   {
       LE_send_msg (MNGRED_OP_VL, 
           "Error occurred setting \"update required\" flag in lookup table");
       LE_send_msg (MNGRED_OP_VL, "Redundant channel data id %d, msg id %d not updated",
                    dataid, msgid);
   }
   return;
}
       

/********************************************************************************

    Description: This routine is the callback routine for redundant manager
                 commands generated by orpg processes (ie. HCI, RMS, 
                 Control_rda, etc.).

          Input: lbd     - the descriptor of the lb that initiated the callback
                 msgid   - the id of the message that changed
                 msg_len - the length of the message
                 data_id - the id of the lb that initiated the callback

         Output:

         Return:

        Globals: CHAnnel_link_state      - see mngred_globals.h & orpgred.h
                 CHAnnel_state           - see mngred_globals.h & orpgred.h
                 CONfiguration_type      - see mngred_globals.h
                 REDundant_channel_state - see mngred_globals.h
 
          Notes: The cmd msg contains a pointer to the LB and msg id to 
                 update on the redundant channel
 
 ********************************************************************************/

void PC_process_on_demand_event (int lbd, LB_id_t msgid, int msg_len,
                                 void *data_id)
{
   int  return_val;              /* return value from function calls */
   Redundant_cmd_t orpg_command; /* the orpg command to process */

      /* read the command msg */

   return_val = ORPGDA_read (ORPGDAT_REDMGR_CMDS, &orpg_command,
                             sizeof (Redundant_cmd_t), LB_NEXT);

      /* if the configuration is FAA redundant, check the conditions to see if
         the command should be processed */

   if (CONfiguration_type == ORPGSITE_FAA_REDUNDANT)
   {
      if ((REDundant_channel_state == ORPGRED_CHANNEL_ACTIVE    &&
           CHAnnel_link_state == ORPGRED_CHANNEL_LINK_UP)
                              ||
          (REDundant_channel_state == ORPGRED_CHANNEL_INACTIVE  &&
           CHAnnel_state == ORPGRED_CHANNEL_INACTIVE            &&
           orpg_command.cmd != ORPGRED_UPDATE_ALL_MESSAGES))
               return;
   }
   else  /* check for NWS redundant commands */
   {
      if (CONfiguration_type == ORPGSITE_NWS_REDUNDANT        &&
          orpg_command.cmd != ORPGRED_DOWNLOAD_CLUTTER_ZONES)
              return;
   }

      /* process all commands in the queue (rarely will there be more
         than one command in the queue) */

   while (return_val > 0)
   {

      LE_send_msg (MNGRED_DEBUG_VL, "On_demand cmd received");
      LE_send_msg (MNGRED_DEBUG_VL, 
                   "       cmd:        %d", orpg_command.cmd);
      LE_send_msg (MNGRED_DEBUG_VL, 
                   "       lb_id:      %d", orpg_command.lb_id);
      LE_send_msg (MNGRED_DEBUG_VL, 
                   "       msg_id:     %d", orpg_command.msg_id);
      LE_send_msg (MNGRED_DEBUG_VL, 
                   "       parameter1: %d", orpg_command.parameter1);
      LE_send_msg (MNGRED_DEBUG_VL, 
                   "       parameter2: %d", orpg_command.parameter2);
      LE_send_msg (MNGRED_DEBUG_VL, 
                   "       parameter3: %d", orpg_command.parameter3);
      LE_send_msg (MNGRED_DEBUG_VL, 
                   "       parameter4: %d", orpg_command.parameter4);
      LE_send_msg (MNGRED_DEBUG_VL, 
                   "       parameter5: %d", orpg_command.parameter5);

      switch (orpg_command.cmd)
      {
         int lb_update_type; /* defines type of LB update (one or all) */

          /********** UPDATE_ONE_MESSAGE code has been replaced with callback 
            routine PC_process_adapt_dat_update_event (...). The original
            design had the operator interface generate a command which was
            sent to the redundant manager everytime an Adaptation Data message
            was updated. This design was replaced with an Adaptation Data 
            callback which got the operator interface out of the business 
            of having to deliberately notify the redundant manager of single
            message Adaptation Data updates.
            This code has been left in encase the decision is made for
            the operator interface to manually notify the redundant manager of
            single message updates.
            
         case ORPGRED_UPDATE_ONE_MESSAGE:
            if (CHAnnel_state == ORPGRED_CHANNEL_INACTIVE)
            {
               CHAnnel_status.adapt_dat_update_time = time (NULL);
               break;
            }

            if ((Redundant_channel_status.adapt_dat_update_time   != 
                 CHAnnel_status.adapt_dat_update_time)             ||
                (CHAnnel_link_state == ORPGRED_CHANNEL_LINK_DOWN)  ||
                (redun_chanl_stat_msg.rpg_rpg_link_state == 
                 ORPGRED_CHANNEL_LINK_DOWN))
                       lb_update_type = MNGRED_UPDATE_ALL_LBS;
           else
                       lb_update_type = MNGRED_UPDATE_ONE_LB;

           CHAnnel_status.adapt_dat_update_time = time (NULL); **************/

            /* fall through to the next case stmnt */ 
         case ORPGRED_UPDATE_ALL_MESSAGES:

                  /****  if (orpg_command.cmd == ORPGRED_UPDATE_ALL_MESSAGES) ****/
               lb_update_type = MNGRED_UPDATE_ALL_LBS;

               /* set the "update required" flag in the lookup table according 
                  to the command type */

            return_val = MLT_set_update_required_flag (orpg_command.lb_id, 0, 
                                     orpg_command.msg_id, lb_update_type, 
                                     MNGRED_TRANSFER_ADAPT_DATA);

            if (return_val == -1)
            {
               LE_send_msg (GL_ERROR, 
                "Error setting lookup table \"update required\" flag for data_id %d, msg_id %d",
                orpg_command.lb_id, orpg_command.msg_id);
               
               LE_send_msg (GL_STATUS | GL_ERROR, 
                            "Error updating redundant channel's Adaptation Data");
            }

            if (!ORPGRED_version_numbers_match ())
               MA_force_adapt_dat_update ();

            break;

         case ORPGRED_DOWNLOAD_CLUTTER_ZONES: /* cmd to dnld censor zones to RDA */

            LE_send_msg (MNGRED_TEST_VL, "DOWNLOAD_CLUTTER_ZONES ORPG cmd received");
   
            if (CONfiguration_type == ORPGSITE_NWS_REDUNDANT)
               DC_set_redun_rda_dnld_cmd (orpg_command);
            else  /* FAA redundancy is assumed */
                  /* set the IPC channel command to send the command to the 
                     other channel */
               DC_set_IPC_cmd (ORPGRED_DNLOAD_CLUTTER_CENSOR_ZONES, 
                               orpg_command.parameter1, orpg_command.parameter2, 
                               0, 0, 0);
            break;

         case ORPGRED_VCP_RDA_CONTROL:   /* cmd to send new VCP or control cmd to RDA */

            LE_send_msg (MNGRED_TEST_VL, "VCP_RDA_CONTROL ORPG cmd received");

               /* set the IPC channel command to send the command to the 
                  other channel */

            if ((REDundant_channel_state == ORPGRED_CHANNEL_INACTIVE) &&
               (CONfiguration_type == ORPGSITE_FAA_REDUNDANT))
            {
               if (orpg_command.parameter1 == COM4_RDACOM) 
               {
                   if (orpg_command.parameter2 == CRDA_SELECT_VCP)
                       DC_set_IPC_cmd (ORPGRED_SELECT_VCP, orpg_command.parameter3, 
                                       0, 0, 0, 0);
                   else if (orpg_command.parameter2 == CRDA_SR_ENAB     ||
                            orpg_command.parameter2 == CRDA_SR_DISAB)
                       DC_set_IPC_cmd (ORPGRED_UPDATE_SR, orpg_command.parameter2, 
                                       0, 0, 0, 0);
                   else if (orpg_command.parameter2 == CRDA_CMD_ENAB    ||
                            orpg_command.parameter2 == CRDA_CMD_DISAB)
                       DC_set_IPC_cmd (ORPGRED_UPDATE_CMD, orpg_command.parameter2, 
                                       0, 0, 0, 0);
                   else
                       LE_send_msg (MNGRED_OP_VL, 
                             "Invalid VCP_RDA_CONTROL COM4_RDACOM cmd rec'd (parm 2: %d, parm 3: %d)", 
                             orpg_command.parameter2, orpg_command.parameter3);
               }
               else if (orpg_command.parameter1 == COM4_DLOADVCP)
                    DC_set_IPC_cmd (ORPGRED_DOWNLOAD_VCP, orpg_command.parameter2, 
                                    0, 0, 0, 0);
               else
                  LE_send_msg (MNGRED_OP_VL, 
                        "Invalid VCP_RDA_CONTROL cmd 1 rec'd (parameter 1: %d)", 
                        orpg_command.parameter1);
            }

            break;

         default:
            LE_send_msg (GL_ERROR, 
                         "Unsupported command received from ORPG (cmd %d)",
                         orpg_command.cmd);
            break;
      }
         /* read the next command in the queue */

      return_val = ORPGDA_read (ORPGDAT_REDMGR_CMDS, &orpg_command,
                                sizeof (Redundant_cmd_t), LB_NEXT);
   }

   if (return_val != LB_TO_COME)
      LE_send_msg (GL_ERROR, 
            "Error reading the redundant mgr orpg command LB (err %d)",
            return_val);

   return;
}


/********************************************************************************

    Description: This is the callback routine for the interval timer alarm.
                 The interval timer expired flag is set here.

          Input:

         Output:

         Return:

        Globals: INTerval_timer_expired - see mngred_globals.h
 
          Notes:
 
 ********************************************************************************/

void PC_process_timer_expired_event ()
{
   INTerval_timer_expired = MNGRED_TRUE;
   return;
}
