C 
C RCS info 
C $Author: steves $ 
C $Locker:  $ 
C $Date: 2004/01/15 16:37:02 $ 
C $Id: a3148l.ftn,v 1.4 2004/01/15 16:37:02 steves Exp $ 
C $Revision: 1.4 $ 
C $State: Exp $ 
C 
      SUBROUTINE A3148L__PPS_RUN_LENGTH_ENCODE (INBUF, OUTBUF,
     $                   B3STIDX, CLRTBL_IDX)
*.********************************************************************
*.                    M O D U L E  P R O L O G U E
*.
*.  MODULE NAME: A3148L__PPS_RUN_LENGTH_ENCODE
*.
*.  MODULE VERSION: 0000
*.
*.  MODULE LANGUAGE: FORTRAN
*.
*.  CHANGE HISTORY:
*.
*.       DATE          VERSION   PROGRAMMER           NOTES
*.       ----------    -------   ----------------     --------------------
*.       05 10 95      0000      TIM O'BANNON         CCR 94-33207
*.
*.  CALLING SEQUENCE: CALL A3148L__PPS_RUN_LENGTH_ENCODE (INBUF,
*.                                 OUTBUF,B3STIDX,CLRTBL_IDX)
*.
*.  MODULE FUNCTION:
*.    Performs radial run-length-encoding of polar graphics PPS products.
*.    Includes formatting the radial header information.
*.
*.  MODULES CALLED: A3CM01__RUN_LENGTH_ENCODE
*.
*.  PARAMETERS:          (*:  G = GLOBAL, C = COMMON, P = PASSED)
*.
*.    *   INPUT      TYPE        DESCRIPTION
*.    -   -----      ----        -----------
*.
*.    *   OUTPUT     TYPE        DESCRIPTION
*.    -   ------     ----        -----------
*.
*.    *   ACTUAL ARGUMENTS  TYPE        DESCRIPTION
*.    -   ----------------  ----        -----------
*.
*.  DATABASE/FILE REFERENCE: None
*.
*.  INTERNAL TABLES/WORK AREA:
*.
*.    NAME         TYPE    DESCRIPTION
*.    ----         ----    -----------
*.
*.  GLOBAL BLOCKS REFERENCED:
*.
*.  COMMON BLOCKS REFERENCED:
*.
*.  ERROR CONDITIONS: NONE
*.
*.  ASSUMPTIONS/RESTRICTIONS:  None
*.
*.  DEVIATION FROM STANDARDS:  None
*.
*.  COMPILATION INSTRUCTIONS:
*.
*.    THIS MODULE IS COMPILED USING THE COMP14.CSS
*.
*.  LINKAGE INSTRUCTIONS:
*.
*.    THIS MODULE IS LINKED USING THE LINK14.CSS
*.
*.  MISC:  N/A
*.
*.*******************************************************************
C
C** 'X' IN COLUMN-1 INDICATES CONDITIONALLY COMPILED DEBUG CODE...
C
      IMPLICIT NONE
C
$INCLUDE A309.INC/G,**A3PM01 (NEND NLIST)
$INCLUDE A3146.INC/G, **A3146P1(NEND NLIST)
C
C
      INTEGER*2 INBUF(*)
      INTEGER*2 OUTBUF(*)
C
C  RADIAL DATA PACKET HEADER VARIABLES
      INTEGER*2 OPCODE,ICENTER,JCENTER
      PARAMETER (OPCODE=X'AF1F', ICENTER=256, JCENTER=280)
      INTEGER*2 SCALE,NUMRAD
      PARAMETER (SCALE=2000, NUMRAD=360)
C
C  LOCAL VARIABLES
      INTEGER AZ,ZERO,ONE,TWO,TEN,ROUND
      PARAMETER (ZERO=0,ONE=1,TWO=2,TEN=10,ROUND=5)

      INTEGER I4WORD,DIVIDER,BLOCKID
      PARAMETER (DIVIDER=-1, BLOCKID=1)

      INTEGER BUFFIND, NUMBINS
      PARAMETER(NUMBINS=115)
      INTEGER*2 RADIAL(NUMBINS)
      INTEGER START,RLEBYTS
      INTEGER EST_PER_RAD,BUFSIZ
      INTEGER NRLEB, NRLEI2, PTR, GATE
      INTEGER B3STIDX, CLRTBL_IDX
      INTEGER EXCESS,HEADER_STUFF
      PARAMETER(HEADER_STUFF=150)
      DATA EST_PER_RAD /63/
      DATA BUFSIZ /23000/
C
C  USED IN CALL TO A3CM01_RLE
      INTEGER DELTA,BEGPTR,ENDPTR,BUFFSTEP
      PARAMETER(BEGPTR=ONE, ENDPTR=NUMBINS, BUFFSTEP=ONE)
C
C
C*************** EXECUTABLE ****************
C
C  SET UP RADIAL DATA PACKET HEADER BLOCK
C
      OUTBUF(OPCDOFF)  = OPCODE
      OUTBUF(FRBOFF)   = ZERO
      OUTBUF(NRBOFF)   = NUMBINS
      OUTBUF(ICNTOFF)  = ICENTER
      OUTBUF(JCNTOFF)  = JCENTER
      OUTBUF(SFACOFF)  = SCALE
      OUTBUF(RADOFF)   = NUMRAD
C
C  INITIALIZE POINTERS
C
      BUFFIND = RADOFF + ONE
      NRLEB = ZERO
C
C  DO FOR EACH AZIMUTH
C
      DO 100 AZ = ZERO, NUMRAD-ONE
C
C  SCALE INTEGER FOR STARTING ANGLE
C
         START = AZ * TEN
C
C  DELTA AZIMUTH ANGLE  - ONE DEGREE IN TENTHS OF A DEGREE
C
         DELTA = TEN
C
C  **FIRST RADIAL IS A SPECIAL CASE TO CORRECT FOR A RAMTEK GLITCH
C  **NEED TO START AT 359 DEGREES AND MAKE DELTA TWO DEGREES
C
         IF (AZ .EQ. ZERO) THEN
            START = (NUMRAD - ONE) * TEN
            DELTA = TWO * TEN
         ENDIF
C
C  COMPUTE POINTER TO EACH RADIAL
C
         PTR = AZ * NUMBINS
C
C  BUILD A SINGLE RADIAL OF DATA FOR INPUT TO A3CM01
C
         DO 200 GATE = ONE, NUMBINS
            RADIAL(GATE) = INBUF(GATE+PTR)
  200    CONTINUE
C
C  CALCULATE NUMBER OF WORDS LEFT IN OUTPUT BUFFER
C  IF THERE ENOUGH LEFT, RUN LENGTH ENCODE THE RADIAL
C
         EXCESS = BUFSIZ - ((NRLEB+HEADER_STUFF)/4)
         IF(EXCESS.GT.EST_PER_RAD) THEN
            CALL A3CM01__RUN_LENGTH_ENCODE(START,DELTA,RADIAL,
     1                   BEGPTR,ENDPTR,NUMBINS,BUFFSTEP,
     2                   CLRTBL_IDX,RLEBYTS,BUFFIND,OUTBUF)
C
C  UPDATE POSITION COUNTERS
C
            NRLEB = NRLEB + RLEBYTS
            BUFFIND = BUFFIND + RLEBYTS/2
         ENDIF
  100 CONTINUE
C
      NRLEI2 = NRLEB/2
      B3STIDX = RADOFF + ONE + NRLEI2
C
C  SET UP HEADER TO BLOCK1
C
      call RPG_set_product_int( OUTBUF(OPRMSWOFF), PHEADLNG )
C
C  FILL IN BLOCK HEADER OVERHEAD DATA
C
      OUTBUF(DIV2OFF)    = DIVIDER
      OUTBUF(BLOCKIDOFF) = BLOCKID
C
C  FILL IN LAYER LENGTH AND DIVIDER
C
      I4WORD = (NRLEI2 * TWO) + DHBYTES
      call RPG_set_product_int( OUTBUF(LYRLMSWOFF), I4WORD )
      OUTBUF(NLYROFF)    = ONE
      OUTBUF(LYRDIVOFF)  = DIVIDER
C
      I4WORD = I4WORD + BLKOVRHD
      call RPG_set_product_int( OUTBUF(LRMSWOFF), I4WORD )
C
      RETURN
      END
