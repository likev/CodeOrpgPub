gdc (1) 		   	ORPG Manpage   			gdc(1)

    
NAME
    gdc - A tool that generates site dependent configuration files by
    interpreting a template file. This tool was initially designed for
    generating site-dependent CISCO device configuration files. It can be used
    for generating other site-dependent configuration files as well.
    
SYNOPSIS
    gdc [options] -s site input_file
    
DESCRIPTION

    "gdc" reads template file "input_file" and generates configuration file for
    site "site". "site" is a name that is used for accessing data files. The
    name must be unique for all sites. For example, for WSR88D the ICAO may be
    used and for OPUP we may use the PUP ID. The site name is a variable and
    thus it must follow the requirements for variable names (Refer to section
    VARIABLES).

    "gdc" reads data files to get site data. These files are assumed to be
    located in the source directory specified by the "-S" option. The default
    source directory is the current directory. "input_file" is assumed to be in
    the source directory unless its full path is specified.

    If "site" is "ALL_SITES", configuration files for all sites are generated.
    To process "ALL_SITES", gdc must have a list of the names of all sites. The
    list is assumed to get from a data file. The data access search path (Refer
    to Section "DATA FILE ACCESS") for getting the list must be specified with
    control variable _gdc_get_all_sites. This can be done by using the gdc's -d
    option, putting it in the default variable definition file (Refer to
    Section "VARIABLE DEFINITION FILE"), or using environmental variable
    GDC_VARIABLES.

    The site configuration file generated by "gdc" is named by
    "input_file.site", or "input_file.site.2" for redundant channel 2, unless
    the name is specified by the "-o" option. The output file is created in the
    destination directory specified by option "-D", if the file name is not
    already a full path. The default destination directory is the current
    directory. If "site" is "ALL_SITES", -o option is ignored and all site
    files are generated in the destination directory.

	A template file is an ASCII text file consisting of ordered lines. If
    the first non-empty character (space, tab and line-return are empty
    characters) on a line is "!", the line is considered as comment line and
    passed to the output with variables replaced by their values. If the first
    non-empty character is "#", the line is considered as a local comment line
    which is not passed to the output. If the first character of a line is "^",
    the line is not processed and passed through with "^" removed. If the last
    character of a line is "\", this line is considered to be continued by the
    next line ("\" and the following line return are discarded). The carriage
    return character "\r", used by Windows, is discarded if any.

    The output lines are processed by indentation. (n_spaces modulo
    (indent_width + 1)) spaces are put in front of each line where "n_spaces"
    is the number of spaces (tab is considered as 8 spaces) before indentation
    and "indent_width" is the specified indentation width (the maximum number
    of spaces used for indentation). The default of "indent_width" is 1 (for
    CISCO styled indentation). To use an alternative "indent_width", See "USING
    ALTERNATIVE INTERPRETING". If indentation is on, empty lines in the output
    are discarded.

    The special-purpose characters of the above "^", "!", "#" and some other
    reserved control characters (i.e. "=", ";", etc.) introduced later can be
    replaced by any other characters if required for avoiding ambiguities.
    Refer to Section "USING ALTERNATIVE INTERPRETING".
 
    A template file is a configuration file that has variables and control
    structures in it. They may be site dependent. To create the configuration
    file for a given site, the variables are evaluated (i.e. replaced by their
    values) for the site and the site-specific file is then created based on
    the values of the variables. If a variable does not have an value, it is
    considered to be undefined. Undefined variables are not replaced.


    VARIABLES

    A variable is a character "$" followed by the variable name wrapped by "{"
    and "}". If there is no ambiguity, "{" and "}" can be omitted. The
    characters in the variable name must be letters, digits, "_" or "-". For
    example, in the following line,

	$v1 This$ is ${Va2} T$v3.12.$Bh${N}g$ ${a.b}

    there are 5 variables. Their names are "v1", "Va2", "v3", "Bh" and "N"
    respectively. Note that the second "$" and the last two "$" do not
    introduce a variable. The braces around "Va2" are not necessary while the
    braces around "N" is necessary because, otherwise, the variable name would
    be "Ng" instead of "N". Variable names are case-sensitive. That is "v1" is
    not the same as "V1". Variable name cannot be "YES", "IF", "ELSE", "NOT",
    or "ELSEIF" which are reserved names. If the name of a variable is too long
    (more than 250 characters), it is not considered as a variable.

    Variable names starting with "_gdc_" are reserved for gdc's control
    variables. They should not be used for other purposes (The results are 
    undefined otherwise).

    If a variable is assigned a value it is a defined variable. Otherwise it is
    undefined. The value of a variable is a character string of any characters
    of any length. For example, an empty string contains no character is a
    valid value. "gdc" initializes the values of a set of internally-defined
    variables before processing the template file. The pre-defined variables
    are listed later in this document. Assigning a value to a variable, called
    defining a variable, can be conducted by the assignment statement
    (explained next in this section), through the gdc's -d option or via an
    environmental variable (See "GDC ENVIRONMENT"). If the same variable is
    defined in multiple places, the following precedence applies: Defined in
    the latest assignment; Defined by a -d option; Defined by gdc internally;
    Defined by an environmental variable. Variable values are often read or
    deduced from external data files. This can be done by using a variable
    definition file (explained later) in which one can read data files, compute
    variable values and define variables.

    If a variable's name is consisted of all lower-case characters, but not
    "site_name", it is considered as local to the file or to the procedure
    (explained later) if used in a procedure. This allows us to hide temporary
    variables from being seen from other places.

    One can set the value of a variable with the assignment statement in the
    template file. An assignment statement does not generate any configuration
    in the output file. An assignment statement uses the format "SET name =
    value" where "name" is a variable name and "value" is the value to assign.
    This is the full format. In short format, word "SET" is optional. (See
    "USING ALTERNATIVE INTERPRETING" for how to switching to the short format).
    For example,

	SET My_var = This is the value

    assigns the value of "This is the value" to variable "My_var". Note that
    there must be no "$" in front of the variable name. Spaces or tabs around
    "=" is ignored. For example the above line is identical to any of the
    following two lines.

	SET My_var=  This is the value

	SET My_var=This is the value

    If "My_var" has been assigned a value before this, the old value is
    discarded and the new one is assigned.

    Multiple lines of value can be assigned to a variable. For example,

	SET My_var = {
	    line 1
	    line 2
	}

    where the value assigned to "My_var" is the character string starting with
    the character after "{" and ending with the character before "}". Note that
    here we use "{" and "}" to wrap a section containing multiple lines.

    Lines wrapped by "{" and "}" is called a section. When wrapping a section,
    the following are identical to the previous example:

	SET My_var = 
	{
	    line 1
	    line 2
	}

	SET My_var = {
	    line 1
	    line 2 }

	SET My_var = { line 1
		   line 2 }

    This formatting freedom of wrapping a section will apply to other types of
    sections described latter.

    It is possible that the template text has a non-assignment line which can
    be interpreted as an assignment. In this case, we can choose a different
    assignment character other than "=". Refer to "USING ALTERNATIVE
    INTERPRETING". Note that the full format is much less likely to cause
    ambiguity in interpreting the template.

    All variables with value in the template file are replaced by their values.
    For example,

	SET v1 = is 12
	This $v1. $v2.

    will be evaluated as 

	This is 12. $v2.

    Note that variable "v2" is not replaced because it has no defined value.

    Variables are recursively evaluated. For examples, 

	SET v1 = var
	SET var = &*
	${$v1}

    ${$v1} will be evaluated as "&*".

	SET var = &*
	SET text = {
	  var is $var
	}
	$text

    "$text" will be evaluated as 

	var is &*

    Empty lines created by variable replacement are discarded. When a line is
    ready for output, some of the leading spaces may be removed.


    GDC ENVIRONMENT

    One can use environmental variables for pre-defining gdc variables. There
    are two recognized ways for this. First, if an environmental variable has
    the same name as the gdc variable to be evaluated, the value of the
    environmental variable is used for the value of the variable. Second, one
    can put variable definitions in environment variable GDC_VARIABLES. For
    example, both "MY_GDC_VAR=something" "GDC_VARIABLES="MY_GDC_VAR=something"
    define variable MY_GDC_VAR. One can put multiple variable definitions,
    separated by ";" in GDC_VARIABLES. In particular, gdc control variables
    _gdc_get_all_sites and _gdc_include can be pre-set with environmental
    variables. One can set _gdc_include multiply for multiple files.


    CONDITIONAL CONTROL

    A condition statement is any line starting with one of the following: "IF
    condition:", "ELSEIF condition:" or "ELSE:". Spaces around ":" are ignored.
    gdc also supports the "short format" where word "IF" can be omitted. To
    switch to the "short format", see "USING ALTERNATIVE INTERPRETING". The
    full format is less likely to cause ambiguity in interpreting the template
    while the short form is more compact. To avoid ambiguity, one may choose to
    use a different control character other than ":". See "USING ALTERNATIVE
    INTERPRETING".

    The statement "condition" in the above format is a list of tokens. Each
    token must be a variable, $var==string or $var!=string where "var" is any
    variable and "string" is any character string. "string" can have variables.
    "string" can have wild card "*" which indicates any string. The "$" in
    front of variables in a condition statement can be omitted. For example,
    "FAA NWS:" and "$FAA $NWS:" are condition statements and they are
    identical. A condition statement is considered "true", if any of the tokens
    in the statement satisfies one of the following: 1. If the token is a
    variable and it has the value of "YES" (case sensitive). 2. If the token is
    $var==string and the value of "var" equals to "string". 3. If the token is
    $var!=string and the value of "var" does not equal to "string". If "string"
    contains spaces, the entire token must be quoted by " (e.g. "SITE_TYPE==NWS
    SITE"). "string" can be an empty string (no character) (e.g. MY_VAR!= is
    true if variable MY_VAR is defined and not empty). The empty "condition" is
    fine and considered as "false". "IF", "ELSEIF" and "ELSE" cannot be a part
    of "condition".

    Examples: The condition statement "IF FAA NWS:" is "true" if $FAA is "YES"
    OR $NWS is "YES". "IF SITE_TYPE==FAA SITE_TYPE==NWS:" is "true" if
    $SITE_TYPE is "FAA" or "NWS". "IF MY_VAR==*" is true if $MY_VAR is defined.

    The line of, or the section following, a condition statement is discarded
    if the statement is not "true". For example

	SET v1 = YES
	IF v1: v1 is true

    will be evaluated as

	v1 is true

    while

	IF v1: v1 is true
	
    will be evaluated as nothing if v1 has no value. If the line or section
    after a conditional line or section is lead by "ELSE:", the line or section
    after "ELSE:" is discarded if the statement is "true". For example,

	SET v1 = YES
	IF v1: v1 is true
	ELSE: v1 is not true

    will be evaluated as

	v1 is true

    while 

	SET v1 = 
	IF v1: v1 is true
	ELSE: v1 is not true

    will be evaluated as

	v1 is not true

    because $v1 is not "YES".

    Here are more examples: 
	
	IF FAA: 
	ELSE: {
	    line 1
	    line 2
	}

    will be evaluated as nothing if $FAA is "YES". Otherwise, the two lines 
    in the section after "ELSE:" are taken.
	
	IF FAA: {
	    This is FAA
	}
	ELSE: This is not FAA

    will be evaluated as

	This is FAA

    if $FAA is "YES". Otherwise, it will be evaluated as

	This is not FAA

    Word "NOT" can be added in front of a condition statement for inverting the
    condition. For example, "IF NOT FAA:" is true if FAA is not "YES". Note that
    NOT inverts the entire condition statement, not the first token in the
    statement. For example, "IF NOT FAA NWS:" is true if "IF FAA NWS:" is false.
    "NOT" cannot be added in front of "ELSE". As one more example, the
    following

	IF NOT FAA: This is not FAA

    is equivalent to 

	IF FAA:
	ELSE: This is not FAA

    Word "ELSEIF" in front of a condition statement indicates an "else if"
    section. For example,

	IF FAA: This is FAA
	ELSEIF FR_SITE: This is non-FAA FR site
	ELSE:	  This is other cases

    will be evaluated as "This is FAA" if $FAA is "YES". Otherwise, if $FR_SITE
    is "YES", the output will be "This is non-FAA FR site". If both $FAA and
    $FR_SITE are not "YES", the output will be "This is other cases".

    Note that "ELSEIF" and "ELSE" must follow immediately an "IF" or an
    "ELSEIF" section. In short format, "IF" is optional.

    To specify the "AND" condition (e.g. Both FAA and DIST_MSCF are "YES"),
    because sections can be nested, one can do the following:

	IF FAA: IF DIST_MSCF: this is the line
    or
	IF FAA: IF DIST_MSCF: {
	    this is the line
	}
    or 
	IF FAA: {
	    IF DIST_MSCF: this is the line
	}

    Line "this is the line" is not discarded only if values of both $FAA and
    $DIST_MSCF are "YES". Note that the first two are considered as identical
    to the last. One can also define a new variable for an AND condition. For
    example,

	IF FAA: IF DIST_MSCF: SET FAA_AND_DIST_MSCF = YES	
	IF FAA_AND_DIST_MSCF: this is the line

    The condition part of a condition statement is recursively evaluated up
    to 6 levels. For example, if

	SET nop4 = YES
	SET NOP_site = nop3 nop4

    "IF NOP_site:" is "true". If the condition is not true while the recursive
    level limit is reached, the condition is considered as not true.


    ARRAYS and LOOPING

    Tokens (words) in a variable value can be treated like array elements. For
    example,

	SET var = t1 t2 t3

    "$var[1]" and "$var[3]" will be evaluated as "t1" and "t3". Note that the
    "array" index starts with 1. "$var" is evaluated as "t1 t2 t3" as before.
    Since the array index part is treated as part of the variable name, no
    space is allowed in it. For examples, "$var [1]", "$var[ 1]" or "$var[1 ]"
    are not interpreted as array element. If an array element must contain
    spaces, it can be wrapped by """. For example, var = t1 "t 2" t3 has three
    elements and the second is "t 2". "" represents an empty string element.

    "$var[*]:", or "var[*]:", where "var" is any defined variable, can be used
    for expanding a line (or a section) into multiple lines (or sections). For
    example

	SET var = t1 t2 t3
	SET num = 1 2 
	var[*]: This is line $num[*] (var[*])

    will be evaluated as

	This is line 1 (t1)
	This is line 2 (t2)
	This is line  (t3)

    Note that, here, "var[*]:" introduces a "loop". It loops the line (or the
    section wrapped by "{" and "}") after it for the number of token times. The
    variables with "[*]" in the loop, are evaluated with the current loop index
    for loop variables or the inner loop index for others. Unavailable tokens
    are assumed to be empty. Nested looping is supported. [*] can only be used
    within a loop. Loop index does not pass through procedure calls.


    GDC CONTROL VARIABLES

    gdc control variables are special variables used for various gdc control
    purposes. When such a variables is set to a certain value, gdc is told to
    perform an action or change its behavior there after. One can set gdc
    control variables anywhere in the templates. One cannot use the value of a
    control variable. Currently defined gdc control variables are the
    following.

	_gdc_include - Invokes a variable definition file. See "VARIABLE 
	DEFINITION FILE" for details.

	_gdc_print_variables - Prints the global variables and their values as
	comment lines. The value assigned to this control variable is printed
	as a title. The current behavior of automatically printing variables
	will be removed in the future.

	_gdc_set_data_delimiter - Sets the column delimiter for a data file.
	The default is ",". For example, to tell gdc to use space as column
	delimiter for file hosts.tmpl, one uses the assignment statement: SET
	_gdc_set_data_delimiter = hosts.tmpl " ". Each data file is assumed to
	use a delimiter at any given time.

	_gdc_set_interpreting - Changes how the template is interpreted. Refer
	to "USING ALTERNATIVE INTERPRETING" for more details.

	_gdc_install_file - Specifies how to install the output file for the -I
	option. See "INSTALL THE OUTPUT FILE" for more details.

	_gdc_import_from - Specifies how to import the contents of a file to
	the output file. See "IMPORT FROM EXTERNAL FILE" for more details.

	_gdc_execute - Executes the specified command in the value. If the
	execution fails or the command fails, gdc treats as an error and
	terminates. gdc does not repeat the same command with the same command
	line options.

	_gdc_site_is - Tells gdc a property of the site. The currently defined
	one is "SET _gdc_site_is = redundant" meaning the site is a redundant
	site which has 2 channels. If one does not set this, the configuration
	for channel 2 will not be generated.

	_gdc_error - Reports an error and terminates processing.

	_gdc_add_required_variable - Adds another variable to the list of
	variables that must be defined when they are used (except in
	conditional checking). The variables in the list can have wild card "*"
	which means any character string. For example to make all variables,
	that match FRC_*, required, one uses the assignment statement:
	SET _gdc_add_required_variable = FRC_*.

	_gdc_get_all_sites - Tells gdc the data access path for getting the
	list of all sites. For example, "SET _gdc_get_all_sites =
	hosts.dat>?>1" indicates that the site list is retrieved from column 1
	of all rows in file hosts.dat. Setting _gdc_get_all_sites is required
	for "gdc -s ALL_SITES" to work. It can be done through the gdc's -d
	option, the gdc default variable definition file or environmental
	variable GDC_VARIABLES. Note that, for this control variable, gdc
	searches for the assignment statement in the default variable
	definition file without parsing it. Thus one should not try to put it
	in a conditional section, a loop section or a procedure. It is
	recommended to use GDC_VARIABLES or the -d option for this setting if
	possible.

	_gdc_set_field_delimiter - Sets the delimiter for function "Field". 
	Refer to "BUILT-IN FUNCTIONS".


    USING ALTERNATIVE INTERPRETING

    The control characters "=", ":", "{", "}", "^", "!" and "#" are suitable
    for many configuration files. For other configuration files, different
    control characters may be required for preventing from ambiguities. Any of
    these control characters can be replace by another desired character. By
    setting gdc control variable

	SET _gdc_set_interpreting = inst1 inst2 ...

    we can change these control characters anywhere in the template allowing
    the interpreting to be changed "dynamically". Where inst1, inst2, ... are
    change instructions which has format of
    "default_control_character-new_control_character". For example, instruction
    "=-<" replaces the assignment character "=" by "<". If the new character is
    currently used for another control function, the two are swapped. If
    "new_control_character" is missing, the control character is disabled (e.g
    if "=" is disabled, no line is interpreted as assignment).

    One can also select the "full" format or "short" format for the condition
    and assignment statements. To use the "full" format, use instruction
    "full". To use the "short" format, use instruction "short".

    One must make sure that the new control character, or the format selection
    (short or full) used does not cause ambiguities while the template is
    interpreted. The _gdc_set_interpreting setting has a file scope.

    The following three more instructions are allowed: 1. "indent=indent_width"
    where "indent_width" is the indentation width. If "indent_width" is
    missing, indentation is turned off. 2. "cs_style" sets control characters
    for the CS styled configuration file. In such files, braces "{" and "}" are
    replaced by "<" and ">" because the braces are used in CS files for another
    purpose. The comment line is lead by "#" instead of "!". The indentation is
    turned off. 3. "keep_blank=yes" keeps blank lines and "keep_blank=no"
    removes blank lines. "keep_blank=" uses the default (not keeping blank line
    if indentation is on).

    An example is the following line

	SET _gdc_set_interpreting = cs_style ^-/

    which indicates that the CS style is used and the not-to-process line is
    lead by "/" instead of "^".

    The gdc's -f command line option can be used for setting initial
    alternative interpreting.

    Other control characters used by gdc, such as "$", "[", "]", "*", ">", "."
    and "=" (for data access search path), are not replaceable. Note that any
    of the control characters is treated as a control character only if the
    context dictates.

    The older style of changing control characters by using comment line of

	!  #-f options#  inst1 inst2 ...

    is still supported. It is however not recommended for new development.


    INSTALL THE OUTPUT FILE

    With the -I option, gdc will move the generated site file to a specified
    location (possibly renamed). To specify the install location, one can set
    the gdc control variable

	SET _gdc_install_file = link path on n1 n2 ... of var1 var2 ...

    where the word "link" is optional. If it exists, gdc installs a link to a
    shared file. See -L option for more details.

    "path" is the path of the destination. If "path" start with /, it is
    installed in dest_dir/root/path (with leading / removed from "path").
    Otherwise, if "path" starts with ./, it is then installed in dest_dir/path
    (with leading ./ removed from "path"). Otherwise it is installed in
    dest_dir/user/path (See the example later in this section. Refer to
    restore_adapt). The installed file name can have variables in it. "path"
    can have .tar, .gz or .tar.gz. When .tar presents, the file is tared and
    any char ":" in the name is replaced by "_". This can be used to hide file
    names containing ":" which is not allowed by some programs and file
    systems. When .gz presents, the file is compressed.

    The words after "path" specify conditional installation based on the node
    and site category n1, n2, ... are node names to install. var1, var2, ...
    are variable names which indicate that, if all var1, var2, ... are "YES",
    the file is installed on all nodes of n1, n2, .... Missing "on ..." means
    all nodes. Missing "of ..." means no site category checking. Multiple
    condition statements can appear on the same line separated with ";".

    Install instruction cannot be used in the variable definition file.
    Multiple install instructions are accepted. The file is installed at the
    first matching location. The current node name, which is used for comparing
    with the listed node names to be installed on, is the value of variable
    "NODE_NAME". If this variable is not internally defined, one must define it
    with the -d option.

    As an example, line 

	SET _gdc_install_file = /tftpboot/lan-cfg

    tells gdc to install the output file in dest_dir/root/tftpboot/ and named
    as lan-cfg where dest_dir is the destination file location defined by the
    -D option.

    The older style of specifying install instruction by using comment line of

	!  #Installed link in# path  on n1 n2 ... of var1 var2 ...

    is still supported. It is however not recommended for new development.


    IMPORT FROM EXTERNAL FILE 

    One can instruct gdc to copy contents from another file to the output site
    file. This provides a way of using pre-generated site specific file instead
    of generating from the template. To do this we can set the gdc control
    variable

	SET _gdc_import_from = binary file_name optional

    where "file_name" is the file to copy from. gdc variables can be used in
    "file_name". If "file_name" is not provided with the full path, the file is
    assumed to be in the source file directory defined by the -S option. If the
    file exists, gdc will copy its content to the output file and terminate
    (Any line in the template after the copy instruction is no longer
    processed). A copy instruction cannot be used in the variable definition
    files.

    The word "binary" is optional. If it is specified, gdc does not write a
    comment line to the output file before copying.

    The word "optional" after the file name is also optional. If
    "optional" is specified and the file to copy from does not exist, gdc will
    continue to process the template and generate the site file. If, however,
    "optional" is not specified and the file to copy from does not exist, gdc
    will treat it as an error and terminate with code 1.

    As an example, line

	SET _gdc_import_from = ${site_name}-hub-template

    tells gdc to copy the content of a file named ${site_name}-hub-template,
    located in the source file directory defined by the -S option, to the
    output file.

    The older style of copy instruction by using comment line of

	!  #Copy binary from# file_name optional

    is still supported. It is however not recommended for new development.


    VARIABLE DEFINITION FILE

    A template file can include one or more variable definition files (VDFs).
    The VDFs are used for defining global variables. Each VDF can be used for
    defining a specific group of variables and is only included in templates
    that need them. To include a file called "rpg_net_var.def", one sets gdc
    control variable:

	SET _gdc_include = rpg_net_vars.def

    The VDF file to read is assumed to be in the source directory if its path
    is not fully specified. If it cannot be found in the source directory, we
    try to find it in the directory of "input_file". If an include files is
    missing, gdc fails and terminates. A VDF file can include other VDFs.

    "_gdc_include" can also be defined with the -d option or environmental
    variables (See "GDC ENVIRONMENT"). All specified VDF files are processed
    before processing the main template file. If file "gdc_vars.def" exists in
    the source directory, gdc treats it as a default VDF and read it before
    processing the main template file. One can use the -i option to specify an
    alternative default VDF.

    A VDF is a special type of the template file. The differences are the
    following.

	1. The VDF does not generate any output in the gdc output file. All
    output lines, if any, are discarded or sent to STDOUT (screen), without
    indentation, in verbose mode (A feature useful for debugging VDFs). The VDF
    is used only for defining global variables for the main template.

	2. In variable VDFs one can access data files to get site data. This is
    done by using functions Data and Check_data (See "DATA FILE ACCESS").

	3. In VDFs, one can define and call procedures (See "PROCEDURE CALL").
    Defining procedures can simplify the contents in the VDFs and make them
    more readable.

        4. In VDFs, the text (value) on the right-hand side of an assignment
    statement is processed as an expression before the assignment. An
    expression is a text which may contain variables and functions (Refer to
    "BUILT-IN FUNCTIONS"). Variables and functions are replaces recursively by
    their values while the expression is processed.


    DATA FILE ACCESS

    A data file can be either in the xml format or the spread sheet format. A
    data file with suffix ".xml" is considered as an XML file. Otherwise it is
    treated as a spread-sheet file. To access data in a data file, one uses
    function "Data" (See Section "BUILT-IN FUNCTIONS"). The function
    searches for a particular piece of data that matches a search path.

    A spread-sheet file contains a number of rows and each row contains a
    number of columns. To access data in such a file, we use search path of
    format "file_name>selected_row>column". For example,
    "dod_net.dat>1=$site_name>2" returns the value of the data in file
    "dod_net.dat", at the second column of the row whose first column matches
    "$site_name".

    Here "selected_row" has the format of "column_ind=value_to_select" which
    indicates that the row is selected by matching the "column_ind"-th column
    to a defined value of "value_to_select". If the matching column number is
    1, "1=" can be omitted. "*" can be used in the matching column index
    indicating any column. In the "column" field, one can also put, instead of
    a number, "#" or "cs-ce". If "#" is specified, the number of available
    columns is returned. If "cs-ce" is specified, where "cs" is the index of
    the starting column and "ce" is the index of the ending column, all columns
    from "cs" through "ce" are returned. If "ce" is missing, all columns
    starting from "cs" are returned. The returned columns are space delimited
    and quotation with """ is added if the number of REQUESTED columns is not
    exactly one and quotation is needed (e.g. There is space in the column or
    the column is empty). No space is allowed around "-" in the format. If the
    row selection part is "?", the specified column of all rows are returned
    (comma delimited). For example, hosts.dat>?>1 returns column 1 of all rows
    in file "hosts.dat".

    If there is a non-empty string after the last delimiter, the string is
    considered as a column. Otherwise no column is assumed after the last
    delimiter.

    Each row can have different number of columns. On each row, data columns
    are separated by a delimiter which has a default of ",". Leading, trailing
    spaces and tabs and those around delimiter are ignored. The delimiter for a
    particular data file can be specified by setting the gdc control variable
    "_gdc_set_data_delimiter" (See "GDC CONTROL VARIABLES"). If the delimiter
    is set to " " (space), the columns are assumed to be separated by space or
    tab. In this case, if a column has space in it, it must be quoted by """.
    Any row with first non-space character of #, ! or ^ is considered as a
    comment line and is ignored. If the last character in a line (right before
    the line return) is "\", the line is considered to be continued by the next
    line.

    For an XML data file, the search path is defined as
    file_name>selected_node>selected_node>...>name. The data search is to find
    the attribute value, if "name" is an attribute name, or the element text if
    "name" is missing. The field of "selected_node" specifies a node selected
    by matching the node value or an attribute value to a given value. The
    format is one of the following: a.
    node_name.attribute_name=value_to_select" - for matching an attribute
    value. b. "node_name=value_to_select" - for matching the node text. c.
    "node_name" - for the case where no attribute or node text to match. For
    example, siteinfo.pup_id=$my_pup_id where "pup_id" is an attribute of node
    siteinfo. One does not need to specify the node path from the top level
    node. In this case the first match of the entire variable name is used.

    If "value_to_select" is "?" in any of the "selected_node" fields, where "?"
    indicates matching anything, all matched values (comma delimited) are
    returned. For example, baseinfo.xml>siteinfo.pup_id=?>pup_id returns all
    pup_ids in baseinfo.xml.

    In a data search path, fields "variable name", "file_name", "node_name",
    "attribute_name", "value_to_select" and "name" can contain any characters
    (e.g. space) except the line-return. If there are characters of ".", "=" or
    ">" in them causing ambiguity, one can use quotation """ to wrap these
    fields. Spaces around ">", "=" and "." are not ignored.

    Variables can be used in the data access search path. They are replaced by
    their values before data search. As a matter of fact, the search path is
    treated as an expression. The data fields retrieved from the data file can
    contain variables. They are replaced by their values.


    BUILT-IN FUNCTIONS

    Functions are designed for helping compute and construct values for
    defining variables. Functions are available only in variable definition
    files. A function looks like:

	function_name (parameter1, parameter2, ...)

    where function_name is the function name and parameter1, parameter2, ...
    are the parameters to pass to the function. Parameters are separated by
    unquoted comma. Spaces around the brackets and the separators are ignored.
    Each parameter is an expression. A function has an output. A function in an
    expression is replaced by its output while the expression is processed.
    If a function evaluation fails, gdc aborts processing.

    The currently supported functions are:

	Data (search_path) - Outputs data found in terms of "search_path". See
	Section "DATA FILE ACCESS". The function will fail if the data search
	fails.

	Check_data (search_path) - Outputs YES is the data of "search_path"
	exists or NO is not. See Section "DATA FILE ACCESS". The function will
	fail if the data file does not exist or there is a syntax error in
	search path.

	Arithmetic (expression) - Evaluates "expression" as an arithmetic
	expression and outputs the result (a number). For example, Arithmetic
	(1 + 1) is 2. The operators accepted in the parameter expression are +,
	-, *, /. Brackets ( and ) can be used. The operands involved in an
	operator must be integers and the result is an integer.

	Field (text, ind, delimiter) - Outputs the "ind"-th field of "text"
	separated by "delimiter". The delimiter must be a character. It can be
	specified with quotation if necessary (e.g. " " for space and "," for
	comma). The third parameter is optional. If it is missing, the default
	delimiter of "." is used. If the requested field does not exist, it
	outputs an empty string. One can change the current default delimiter
	by setting gdc control variable "_gdc_set_field_delimiter". e.g. To let
	gdc to use space for the delimiter for function Field there after, one
	can use the assignment statement: SET _gdc_set_field_delimiter = " ".
	To reset the delimiter to "." again, use: SET _gdc_set_field_delimiter
	= "." (or SET _gdc_set_field_delimiter = .). This setting is local to
	the file. For a new file, it starts with the default.

	Net_mask (n_bits) - Outputs the netmask corresponding to "n_bits". For
	example, it outputs 255.255.255.128 if n_bits is 25.

	Change_case (text, how) - Outputs the upper case of "text", if "how" is
	"upper", or the lower case of "text" if "how" is "lower". For example,
	Change_case ("This is", "upper") outputs "THIS IS".


    PROCEDURE CALL

    gdc supports procedure calls in variable definition files. A procedure is a
    section of template that is interpreted when the procedure is called. To
    define a procedure we use key word "procedure". To call a procedure we use
    key word "call". For example, the following section

	procedure my_proc (param1, param2) {
	    input is $param1
	    SET param2 = output from $param1
	}
	SET inp = first
	call my_proc (inp, out)
	$out
	SET inp = second
	call my_proc (inp, out)
	$out

    is evaluated as 

	input is first
	output from first
	input is second
	output from second

    A procedure's name can only use letters, digits, "_" or "-". A procedure
    cannot be redefined. The call statement must call a procedure that is
    already defined. The procedure scope is the file. One cannot call a 
    procedure defined in another file. If a procedure has only one line, the 
    braces can be omitted. For example, the following is fine.

	procedure my_proc (param1, param2) SET param1 = param2

    A brace-wrapped procedure must not have any non-space and non-line-return
    characters between the parameter list and {. For example,

	procedure my_proc (param1, param2) something {
	...

    will be interpreted as a single line procedure.

    One can use a number of parameter variables for a procedure. Parameter
    passing is by reference which means that any modification to a parameter
    variable will change its calling variable. Parameter variables (not calling
    variables) must be local variables (named with all lower case characters).
    Local variables are not seen across the procedure boundary. A procedure
    does not have any return value. In addition to the parameter variables, one
    can use global variables to do input/output.

    Procedure is different from function. A function has an output (i.e. return
    value) while a procedure does not. The procedure uses parameters for both
    input and output while the function's parameters are for input only (passed
    by value). A procedure is merely a section of statements. It does not do
    anything which otherwise cannot be done without it. Functions on the other
    hand are intrinsic and do thing one cannot do without it.


    INTERNALLY DEFINED VARIABLES

    The following is a list of variables internally defined by "gdc" prior to
    processing a template file:

	SITE_NAME = Site name in upper case.

	site_name = Site name in lower case.

	"site name" (Upper case) = YES.

	INPUT_FILE = The base name of the input template file.

	CHAN_NUM = The current channel number in processing. It is available
	only after "SET _gdc_site_is = redundant" is set.


	gdc currently has code to read fr_site.dat which is not an xml file,
	nor a spread sheet file. When the file is read, i.e. _gdc_read_file =
	fr_site.dat is specified in an included variable definition file, the
	following variables may be set (MSCF_IP_O3 and MSCF_IP_O4 may be
	modified if already defined):

	HLMSCF = YES if the site is a MSCF hub router loading site.

	HLRPG = YES if the site is a RPG hub router loading site.

	HLMANUAL = YES if the site is a manual hub router loading site.

	FR_HUB_RPG = "YES" if the RPG has a local FR HUB router (fr_site.dat).

	FR_LOAD_HUB_RPG = "YES" if the RPG is assigned to load a local FR HUB 
	router (fr_site.dat). If this is "YES", FR_HUB_RPG must be "YES".

	FRC_SITE = YES if the RPG router of this site has any FR circuit.

	Variables set if the site is FR circuit site (fr_site.dat):

	FRC_BW = "Bandwidth" of the FR circuit.

	FRC_TSLOT = "t1 timeslots" of the FR circuit.

	FRC_NO_SUBITF = YES if there is no sub-interface defined.

	FRC_SUBITF = YES if there is sub-interface defined.

	FRC_SITE = YES if the RPG router of this site has any FR circuit.

	FRC_RSITE = Name of the client on the remote side of the sub-itf 
	    (RPG ICAO, "SMG" or IP address) (Array for all sub-itfs).

	FRC_DLCI = Array of DLCIs for all sub-itfs.

	FRC_SUBITF_ID = "1 2 ...", sub-itf IDs (Array for all sub-itfs).

	FRC_SUBITF_BG = YES or NO, whether sub-ITF is a bridge (Array for all 
	    sub-itfs).

	FRC_SUBITF_IP = IP of the sub-itf (Array for all sub-itfs).

	    This is defined by column 3 of the sub-interface spec of the FRC 
	    sections in fr_site.dat. Refer to the comments in section "Frame 
	    Relay Circuit Sites" in fr_site.dat.

	FRC_SUBITF_ROUTE = The route for the sub-itf (Array for all sub-itfs).

	    This is set to "sub-network remote_IP"

	    The sub-network is defined by column 2 of the sub-interface spec of
	    the FRC sections in fr_site.dat. Refer to the comments in section
	    "Frame Relay Circuit Sites" in fr_site.dat.

	FRC_SUBITF_ROUTE2 = The second route for the sub-itf (Array for all 
	sub-itfs).

	    Refer to the comments in section "Frame Relay Circuit Sites" in 
	    fr_site.dat.

	MSCF_IP_O3 = The third octet of the MSCF IP. This may be modified while
	    reading fr_site.dat. For frame relay connected MSCF, it is the
	    subnet ID of the hosting RPG network or the value explicitly
	    provided in the second column of the sub-interface specifications
	    for "rule_08" in fr_site.dat.

	MSCF_IP_O4 = The fourth octet of the MSCF IP. This may be modified 
	    while reading fr_site.dat. For frame relay connected MSCF, it is 35
	    or the value explicitly provided in the second column of the
	    sub-interface specifications for "rule_08" in fr_site.dat.

	The following variables are set for Network Management Traffic routes:

	Refer to the descriptions in fr_site.dat for how to set this group of 
	variables.

	NMTP_NET = The subnet for the route (Array for all routes).

	NMTP_IP = The IP for the route (Array for all routes).

	NMTP_WT = The weight for the route (Array for all routes).

	NMTP_DESC = The description for the route (Array for all routes).

	NMTP_DEVICE_TYPE = The device type for the route (Array for all 
	routes). This is set to "RTR" or "FR" indicating respectively the route
	is applied to the RPG router or the FR hub router.


OPTIONS

    "gdc" recognizes the following options:

    -c channel_number

	Specifies the channel number, 1 or 2, for redundant site. The default
	is 1. This option is ignored if "site" is "ALL_SITES".

    -o output_file

	Specifies the output file name. The default is "input_file.site" or
	"input_file.site.2". This option is ignored if "site" is "ALL_SITES".

    -S src_dir

	Specifies the directory for input files. The default is the current 
	directory.

    -D dest_dir

	Specifies the directory for output files. The default is the current 
	directory.

    -i dft_var_def_file

	Specifies the name of the default variable definition file. The default
	is gdc_vars.def. The default variable definition file is optional.

    -d  var=value

	Defines a variable "var" and sets its value to "value". If "var"
	exists, its value is set to "value". This option can be used multiply.
	One can also use this for setting _gdc_get_all_sites.

    -f  instruction

	This option sets initial alternative interpreting used for the template
	file. This option can be used multiply. This option must follow an
	argument which is an instruction as described in "USING ALTERNATIVE
	INTERPRETING".

	Interpreting setting here is used for the main template when its
	processing starts. For other files, the starting setting is the
	default.

    -C  var

	Checks variable "var" and exits with 0 if "var" is YES, 2 if it is not
	defined, 1 on error, or 3 otherwise. In verbose mode, it prints the
	value of "var". Running this option does not need a template. "var",
	however, may need to be set by one or more variable definition files
	(VDFs). gdc invokes VDFs defined with the -d options or in gdc
	environmental variables. gdc also tries to read the default VDF if it
	exists. Note that, if the default VDF is used, one can include
	additional VDFs in it.

    -I

	Installs the site file as specified with _gdc_install_file in the
	template file. The current node name can be provided with "-d
	NODE_NAME=node". See "INSTALL THE OUTPUT FILE" for more details.

    -L  shared_dir,lpath

	This is the same as -I option except the following. If the site file is
	specified with "_gdc_install_file" in the template file, the file
	installed is a link to a share file. The shared file is in shared_dir
	and the site file is a link to "parent_path/lpath/site_file" where
	"parent_path" consists of a number of "../" to point to the top level
	of the site file name. For example, if the site file is
	/root/tftpboot/file_name, "parent_path" then is "../..".

    -v

	Turns on the verbose mode. The verbose mode is turned off when
	processing ALL_SITES.

    -P  routine_name

	Applies built-in routine "routine_name" to "input_file". This may be
	used for converting data files. This is not a part of the basic gdc
	functionality. The currently recognized "routine_name" are:

	"align": Indents the input file so its columns are aligned. The output
	file is named as input_file.a.

	"roc_remote_access_routes": Reads in the network management part of the
	fr_data.dat and converts it to a spread sheet data file of "rocrar.dat"

    -h

	Prints usage info and terminates.

EXAMPLES

    gdc -s ktlx lan_switch

	- Creates device configuration for the RPG LAN switch for site "ktlx".
	The RPG LAN switch template file is "lan_switch". All input and output
	files are located in the current directory. If succeeded, the file
	generated is "lan_switch.KTLX".

    gdc -c 2 -s tjua rpg_router

	- Creates device configuration for the RPG router for redundant channel
	two of site "tjua". The RPG router configuration template file is
	"rpg_router". All input and output files are located in the current
	directory. If succeeded, the file generated is "rpg_router.TJUI.2".

    gdc -s ALL_SITES -D dest lan_switch

	- Creates device configurations for the RPG LAN switch for all sites.
	The RPG LAN switch configuration template file is "lan_switch". All
	input files are located in the current directory. All output files are
	in sub-directory "dest" of the current directory. If succeeded, the
	files generated are named by "lan_switch.site" or "lan_switch.site.2" 
	where "site" is the site name.

    gdc -S ~/cfg/comms -s ktlx -f =-~ -f \!-\; power_admin.conf

	- Creates APC power administrator configuration file for KTLX. The
	device uses "=" in its configuration, so we must use a different
	character for assignment. We use "~" here for this. The device uses ";"
	for comment line instead of "!".

    gdc -s ktlx -D dest -I -d NODE_NAME=rpga lan_switch

	- Creates the lan switch configuration file for node rpga of ktlx and
	installs it in "dest" according to the "_gdc_install_file"
	specification in lan_switch. Refer to section "INSTALL THE OUTPUT 
	FILE".

SEE ALSO


