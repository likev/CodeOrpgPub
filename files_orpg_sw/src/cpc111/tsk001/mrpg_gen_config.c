
/******************************************************************

	file: mrpg_gen_config.c

	Generates the ORPG system config file and distributes it.
	
******************************************************************/

/* 
 * RCS info
 * $Author: jing $
 * $Locker:  $
 * $Date: 2007/03/22 16:16:44 $
 * $Id: mrpg_gen_config.c,v 1.20 2007/03/22 16:16:44 jing Exp $
 * $Revision: 1.20 $
 * $State: Exp $
 */  

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include <orpg.h> 
#include <infr.h> 

#include "mrpg_def.h"

#define STAMP_SIZE 12

#define CHAN_KEY "channel "
#define VERS_KEY "Version "

static char *Version_line = NULL;	/* the version line of new sys_cfg */
static int Version_line_ready = 0;	/* Version_line is ready */
static int Channel_offset;		/* offset of channel #, new sys_cfg */
static int Is_syscfg_new = 0;		/* Is the new sys_cfg new except the 
					   time stamp and channel number? */
static char New_stamp[STAMP_SIZE];	/* time stamp in new sys_cfg */
static int Stamp_offset;		/* offset of time stamp, new sys_cfg */

static char *Get_syscfg (char *hname);
static void Generate_version_line ();
static int Compare_sys_cfg (char *new_syscfg, char *cr_syscfg);
static void Sys_cfg_info_cb (EN_id_t evtcd, char *msg, int msglen, void *arg);


/******************************************************************

    Initializes this module.

    Returns 0 on success or -1 on failure.
	
******************************************************************/

int MGC_init () {
    int ret;

    ret = EN_register (ORPGEVT_SYSTEM_CONFIG_INFO, Sys_cfg_info_cb);
    if (ret < 0) {
	LE_send_msg (GL_ERROR,  "EN_register failed (ret %d)", ret);
	return (-1);
    }

    if (MGC_gen_system_config () < 0)
	return (-1);

    return (0);
}

/******************************************************************

    sys_cfg info request event callback function.
	
******************************************************************/

static void Sys_cfg_info_cb (EN_id_t evtcd, char *msg, int msglen, void *arg) {

    if (msglen == 0 && Version_line_ready) {
	int ret = EN_post_msgevent (ORPGEVT_SYSTEM_CONFIG_INFO, 
		(const char *)Version_line, strlen (Version_line) + 1);
	if (ret < 0)
	    LE_send_msg (GL_ERROR, 
		"EN_post_msgevent SYSTEM_CONFIG_INFO failed (ret %d)", ret);
    }
}

/******************************************************************

    Generates the system config file. If a data/product store is
    specified for a single node, it is accessed globally. Otherwise
    it is treated as a local store.

    Returns 0 on success or -1 on failure.
	
******************************************************************/

#define VERSION_LINE_SIZE 512

int MGC_gen_system_config () {
    Mrpg_dat_entry_t *dat, *pat;
    Node_attribute_t *nodes, **nodeps;
    int n_dat, n_pat, n_nodes, i, ret;
    FILE *fl;
    char tmp_syscfg[MRPG_NAME_SIZE + 16], buf[MRPG_NAME_SIZE * 4 + 32];
    char *syscfg, *out;

    LE_send_msg (LE_VL1, "Generating system configuration file");

    sprintf (tmp_syscfg, "%s.tmp", Get_syscfg (""));
    if ((fl = fopen (tmp_syscfg, "w")) == NULL) {
	LE_send_msg (GL_ERROR, "Creating file %s failed\n", tmp_syscfg);
	return (-1);
    }
    fprintf (fl, "#\n# ORPG system config file - generated by mrpg\n#\n");

    Generate_version_line ();
    fprintf (fl, "\n%s\n\n", Version_line);

    n_nodes = MHR_all_hosts (NULL);
    n_pat = MRD_get_PAT (&pat);
    for (i = 0; i < n_pat; i++) {
	if (pat[i].path[0] != '\0') {
	    int ndn, n;
	    if (MHR_is_distributed () &&
		(ndn = MHR_get_data_hosts (pat[i].data_id, &nodeps))
							!= n_nodes) {
		fprintf (fl, "%d\t", pat[i].data_id);
		for (n = 0; n < ndn; n++)
		    fprintf (fl, "%s:", nodeps[n]->hname);
		if (pat[i].path[0] == '/')
		    fprintf (fl, "%s\n", pat[i].path);
		else
		    fprintf (fl, "$(ORPGDIR)/%s\n", pat[i].path);
	    }
	    else {
		if (pat[i].path[0] == '/')
		    fprintf (fl, "%d\t%s\n", 
					pat[i].data_id, pat[i].path);
		else
		    fprintf (fl, "%d\t$(ORPGDIR)/%s\n", 
					pat[i].data_id, pat[i].path);
	    }
	}
    }

    n_dat = MRD_get_DAT (&dat);
    for (i = 0; i < n_dat; i++) {
	if (dat[i].data_id >= 0 && dat[i].path[0] != '\0') {
	    int ndn, n;
	    if (MHR_is_distributed () &&
		(ndn = MHR_get_data_hosts (dat[i].data_id, &nodeps)) 
							!= n_nodes) {
		fprintf (fl, "%d\t", dat[i].data_id);
		for (n = 0; n < ndn; n++)
		    fprintf (fl, "%s:", nodeps[n]->hname);
		if (dat[i].path[0] == '/')
		    fprintf (fl, "%s\n", dat[i].path);
		else
		    fprintf (fl, "$(ORPGDIR)/%s\n", dat[i].path);
	    }
	    else {
		if (dat[i].path[0] == '/')
		    fprintf (fl, "%d\t%s\n", 
					dat[i].data_id, dat[i].path);
		else
		    fprintf (fl, "%d\t$(ORPGDIR)/%s\n", 
					dat[i].data_id, dat[i].path);
	    }
	}
    }

    fprintf (fl, "\n# The RDA comms link number\n");
    fprintf (fl, "RDA_link  %d\n", MRD_get_RDA_link ());

    fprintf (fl, "\n");
    fprintf (fl, "# END-OF-SYSTEM-CONFIG\n");
    fclose (fl);

    Is_syscfg_new = Compare_sys_cfg (tmp_syscfg, Get_syscfg (""));
    if (Is_syscfg_new < 0)
	return (-1);
    if (Is_syscfg_new) {
	if (MAIN_command () == MRPG_RESUME) {
	    LE_send_msg (GL_ERROR, "mrpg cannot resume - sys_cfg changed\n");
	    return (-1);
	}
	LE_send_msg (LE_VL2, "    New system config file generated");
    }
    else
	LE_send_msg (LE_VL2, "    Use old system config file");

    /* copy system configuration file to all remote nodes */
    n_nodes = MHR_all_hosts (&nodes);
    for (i = 0; i < n_nodes; i++) {
	char name[MRPG_NAME_SIZE * 3 + 32];
	if (!nodes[i].is_local) {
	    LE_send_msg (LE_VL3, 
			"    copy system config to %s", nodes[i].node);
	    if ((syscfg = Get_syscfg (nodes[i].hname)) == NULL)
		return (-1);
	    sprintf (name, "%s:%s.%s", nodes[i].hname, syscfg, nodes[i].node);
	    sprintf (buf, "mv %s.%s %s", syscfg, nodes[i].node, syscfg);
	    ret = RSS_copy (tmp_syscfg, name);
	    if (ret < 0) {
		LE_send_msg (GL_ERROR, 
			"RSS_copy system config to host %s failed (ret %d)\n",
						nodes[i].hname, ret);
		return (-1);
	    }
	    if (MGC_system (nodes[i].hname, buf, &out) != 0) {
		LE_send_msg (GL_ERROR, 
			"%s on %s, failed\n", buf, nodes[i].hname);
		LE_send_msg (GL_ERROR, "    - %s\n", out);
			return (-1);
	    }
	}
    }

    syscfg = Get_syscfg ("");
    sprintf (buf, "rm -f %s", syscfg);
    if (MGC_system ("", buf, &out) != 0) {
	LE_send_msg (GL_ERROR, "%s failed\n", buf);
	LE_send_msg (GL_ERROR, "    - %s\n", out);
		return (-1);
    }
    sprintf (buf, "mv %s %s", tmp_syscfg, syscfg);
    if (MGC_system ("", buf, &out) != 0) {
	LE_send_msg (GL_ERROR, "%s failed\n", buf);
	LE_send_msg (GL_ERROR, "    - %s\n", out);
		return (-1);
    }

    CS_control (CS_CLOSE | CS_UPDATE | CS_DELETE);

    return (0);
}

/******************************************************************

    Completes the system configuration (both file and Version_line)
    by updating the channel number according to the site info. 
    Returns 0 on success or -1 on failure.
	
******************************************************************/

int MGC_complete_sys_cfg () {
    char chan_num[4];
    int chan_updated;

    if (MMR_is_faa_redundant ())
	sprintf (chan_num, "%.2d", MHR_get_channel_number ());
    else
	sprintf (chan_num, "00");

    chan_updated = 0;
    if (memcmp (strstr (Version_line, CHAN_KEY) + strlen (CHAN_KEY), 
					chan_num, 2) != 0)
	chan_updated = 1;

    if (chan_updated) {
	int fd;
	if ((fd = open (Get_syscfg (""), O_RDWR)) < 0 ||
	    lseek (fd, Channel_offset, SEEK_SET) != Channel_offset ||
	    write (fd, chan_num, 2) != 2) {
	    LE_send_msg (GL_ERROR, "Cannot update channel in sys cfg\n");
	    close (fd);
	    return (-1);
	}
	if (!Is_syscfg_new) {
	    if (lseek (fd, Stamp_offset, SEEK_SET) != Stamp_offset ||
		write (fd, New_stamp, STAMP_SIZE) != STAMP_SIZE) {
		LE_send_msg (GL_ERROR, "Cannot update stamp in sys cfg\n");
		close (fd);
		return (-1);
	    }
	    memcpy (strstr (Version_line, VERS_KEY) + strlen (VERS_KEY), 
					New_stamp, STAMP_SIZE);
	}
	close (fd);
	memcpy (strstr (Version_line, CHAN_KEY) + strlen (CHAN_KEY), 
					chan_num, 2);
    }
    Version_line_ready = 1;

    if (Is_syscfg_new || chan_updated) {
	int ret = EN_post_event (ORPGEVT_DATA_STORE_CREATED);
	if (ret < 0)
	    LE_send_msg (GL_ERROR, 
		"EN_post_event (sys_cfg updated) failed (%d)\n", ret);
    }
    return (0);
}

/******************************************************************

    Compares the new system config file "new_syscfg" with the
    current one "cr_syscfg". If they are the same, except the time
    stamp and the channel number, the time stamp of "new_syscfg" is
    set to the current one and 0 is returned. Otherwise "new_syscfg"
    is not changed and 1 is returned (syscfg is new). This function
    returns -1 on failure. If the current sys cfg exists, the
    channel numbers in both the new file and "Version_line" are
    replaced with the channel number in the current sys cfg.
    "Channel_offset" is set for being used in future resetting the
    channel number when site info is available.
	
******************************************************************/

static int Compare_sys_cfg (char *new_syscfg, char *cr_syscfg) {
    int fd_new, fd_cr, size_new, size_cr, ret;
    char *b_new, *b_cr, cr_stamp[STAMP_SIZE], *pc, *ps;

    ret = -1;
    fd_new = fd_cr = -1;
    b_new = NULL;
    fd_new = open (new_syscfg, O_RDWR);
    if (fd_new < 0 ||			/* should never happen */
	(size_new = lseek (fd_new, 0, SEEK_END)) <= 0) {
	LE_send_msg (GL_ERROR, 
		"Cannot open the new sys_cfg (%s)\n", new_syscfg);
	goto close_and_return;
    }
    size_cr = 0;
    fd_cr = open (cr_syscfg, O_RDONLY);
    if (fd_cr >= 0)
	size_cr = lseek (fd_cr, 0, SEEK_END);
    if (size_cr < 0)
	size_cr = 0;

    b_new = malloc (size_new + size_cr + 2);
    if (b_new == NULL) {
	LE_send_msg (GL_ERROR, "malloc failed (%d + %d)\n", size_new, size_cr);
	goto close_and_return;
    }
    b_cr = b_new + size_new + 1;

    lseek (fd_new, 0, SEEK_SET);
    if (fd_cr >= 0)
	lseek (fd_cr, 0, SEEK_SET);
    if (read (fd_new, b_new, size_new) != size_new ||
	(size_cr > 0 && read (fd_cr, b_cr, size_cr) != size_cr)) {
	LE_send_msg (GL_ERROR, "Reading sys_cfg for comparison failed\n");
	goto close_and_return;
    }

    b_new[size_new] = '\0';
    if ((ps = strstr (b_new, VERS_KEY)) == NULL ||
	(ps += strlen (VERS_KEY)) == NULL ||
	ps - b_new + STAMP_SIZE > size_new ||
	(pc = strstr (b_new, CHAN_KEY)) == NULL ||
	(pc += strlen (CHAN_KEY)) == NULL ||
	pc - b_new + 2 > size_new) {
	LE_send_msg (GL_ERROR, 
		"Version line not found in sys_cfg (%s)\n", new_syscfg);
	goto close_and_return;
    }
    Channel_offset = pc - b_new;
    Stamp_offset = ps - b_new;
    memcpy (New_stamp, b_new + Stamp_offset, STAMP_SIZE);

    /* update the new version with the old channel number */
    if (size_cr > 0) {
	char *pcc = NULL;
	b_cr[size_cr] = '\0';
	if ((pcc = strstr (b_cr, CHAN_KEY)) == NULL ||
	    (pcc += strlen (CHAN_KEY)) == NULL ||
	    pcc - b_cr + 2 > size_cr)
	    pcc = NULL;
	if (pcc != NULL) {
	    int channel_offset = pc - b_new;
	    if (lseek (fd_new, channel_offset, SEEK_SET) != channel_offset ||
		write (fd_new, pcc, 2) != 2) {
		LE_send_msg (GL_ERROR, "Version update (channel) failed\n");
		goto close_and_return;
	    }
	    memcpy (strstr (Version_line, CHAN_KEY) + strlen (CHAN_KEY), 
					pcc, 2);
	}
    }

    ret = 1;
    if (size_new != size_cr)
	goto close_and_return;
    memcpy (cr_stamp, b_cr + Stamp_offset, STAMP_SIZE);
    memcpy (b_cr + Stamp_offset, b_new + Stamp_offset, pc - ps + 2);
    if (memcmp (b_new, b_cr, size_new) != 0)
	goto close_and_return;

    /* two files are identical - update the stamp in the new file */
    if (lseek (fd_new, Stamp_offset, SEEK_SET) != Stamp_offset ||
	write (fd_new, cr_stamp, STAMP_SIZE) != STAMP_SIZE) {
	LE_send_msg (GL_ERROR, "Version line update failed\n");
	goto close_and_return;
    }
    memcpy (Version_line + strlen (VERS_KEY), cr_stamp, STAMP_SIZE);
    ret = 0;

close_and_return:
    if (b_new != NULL)
	free (b_new);
    if (fd_new >= 0)
	close (fd_new);
    if (fd_cr >= 0)
	close (fd_cr);
    return (ret);
}

/******************************************************************

    Initializes the Version line of the system configuration and
    stores it in "Version_line".
	
******************************************************************/

static void Generate_version_line () {	/* generate the version line */
    int n_nodes, i;
    Node_attribute_t *nodes, **nodeps;
    char buf[256], *mrpg_host;

    if (Version_line != NULL)
	return;
    Version_line = NULL;
    mrpg_host = "";
    if (MHR_get_task_hosts ("mrpg", &nodeps) > 0)
	mrpg_host = nodeps[0]->hname;
    n_nodes = MHR_all_hosts (&nodes);
    sprintf (buf, "Version %.12lu channel ** n_nodes %d", 
					time (NULL), n_nodes);
    Version_line = STR_copy (Version_line, buf);
    for (i = 0; i < n_nodes; i++) {	/* mrpg host first */
	if (strcmp (nodes[i].hname, mrpg_host) == 0) {
	    Version_line = STR_cat (Version_line, " ");
	    Version_line = STR_cat (Version_line, nodes[i].hname);
	}
    }
    for (i = 0; i < n_nodes; i++) {
	if (strcmp (nodes[i].hname, mrpg_host) != 0) {
	    Version_line = STR_cat (Version_line, " ");
	    Version_line = STR_cat (Version_line, nodes[i].hname);
	}
    }
}

/******************************************************************

    Returns the system config file name on host "hname". NULL is 
    returned on failure.
	
******************************************************************/

static char *Get_syscfg (char *hname) {
    char *p;

    if (!MHR_is_local_node (hname)) {
	int ret;
	char rpc_buf[MRPG_NAME_SIZE + 64];

	sprintf (rpc_buf, "%s:CS_cfg_name", hname);
	if ((ret = RSS_rpc (rpc_buf, "p-r s-i", &p, "")) < 0) {
	    LE_send_msg (GL_ERROR, "RSS_rpc %s failed (ret %d)", rpc_buf, ret);
	    return (NULL);
	}
	if (p != NULL &&
	    (ret = RSS_rpc (rpc_buf, "s-r s-i", &p, "")) < 0) {
	    LE_send_msg (GL_ERROR, "RSS_rpc %s failed (ret %d)", rpc_buf, ret);
	    return (NULL);
	}
    }
    else
	p = CS_cfg_name ("");

    if (p == NULL || strlen (p) == 0) {
	if (hname[0] == '\0')
	    LE_send_msg (GL_ERROR, "ORPG system config file not defined\n");
	else
	    LE_send_msg (GL_ERROR, 
		"ORPG system config file on %s not defined\n", hname);
	return (NULL);
    }

    return (p);
}

/******************************************************************

    Runs command "cmd" on host "hname". Empty "hname" means the 
    local host. The first part (up to MGC_BUF_SIZE bytes) of the 
    output (stdout and stderr) of the "cmd" is returned with
    "output" if it is not NULL.

    If "cmd" is executed in forground (no & in cmd), it returns 
    the status of running "cmd" (as does the "system" function on 
    success) or -1 on failure. If "cmd" is executed in background, 
    it returns the pid of "cmd" on success or a negative error code 
    on failure.
	
******************************************************************/

#define MGC_BUF_SIZE 256

int MGC_system (char *hname, char *cmd, char **output) {
    static char buf[MGC_BUF_SIZE];
    int n_bytes, ret, sys_ret;

    buf[0] = '\0';
    if (output != NULL)
	*output = buf;
    n_bytes = 0;
    if (hname[0] != '\0' && !MHR_is_local_node (hname)) {
	char rpc_buf[MGC_BUF_SIZE];
	if (strlen (hname) + 64 > MGC_BUF_SIZE) {
	    LE_send_msg (GL_ERROR, "command too long in MGC_system\n");
	    return (-1);
	}
	sprintf (rpc_buf, "%s:MISC_system_to_buffer", hname);
	if ((ret = RSS_rpc (rpc_buf, "i-r s-i ba-256-o i ia-o", 
			&sys_ret, cmd, buf, MGC_BUF_SIZE, &n_bytes)) < 0) {
	    LE_send_msg (GL_ERROR, "RSS_rpc %s failed (ret %d)", rpc_buf, ret);
	    return (-1);
	}
    }
    else
	sys_ret = MISC_system_to_buffer (cmd, buf, MGC_BUF_SIZE, &n_bytes);

    buf[MGC_BUF_SIZE - 1] = '\0';
    if (n_bytes >= 0 && n_bytes < MGC_BUF_SIZE)
	buf[n_bytes] = '\0';
    if (hname[0] != '\0')
	LE_send_msg (LE_VL3, "    run %s on %s returns %d (%d)\n", 
					cmd, hname, sys_ret, n_bytes);
    else
	LE_send_msg (LE_VL3, "    run %s returns %d (%d)\n", 
					cmd, sys_ret, n_bytes);
    return (sys_ret);
}


