
NAME
    The LE (Log/Error) module - For Error/Info/Status logging.

SYNOPSIS
    #include <infr.h> or #include <le.h>

    int LE_init (int argc, char **argv);

    int LE_set_option (char *opt_name, ...);

    void LE_send_msg (int code, char *format, ...);

    void LE_log (char *format, ...);


    The following functions are used for special purposes:

    void LE_terminate (void (*term_func)(), int status);

    void LE_set_vl (unsigned int host_ip, int pid, int new_vl);

    void LE_set_callback (void (*callback) (char *, int));

    int LE_dirpath (char *buf, size_t buf_size);

    int LE_fd ();

DESCRIPTION

    The log-error messaging (LE) module is a formatting and distribution tool 
    for log and error messages. The LE provides the following support:

	Supplies additional information such as the process name (or label),
	message report time, process ID, as well as the source file name and
	the line number where the message is reported.

	Prints LE messages in a unified format.

	Monitors LE messages, while a process is running, locally or remotely.

	Efficiently and reliably generates permanent LE messages archive.

	Protects the computing environment from being deteriorated by LE 
	message overwhelming.

	Supports both machine and human LE message interpretations in both
	operational and development environments.

	Supports verbose levels, which can be changed while application is
	running.

    Function LE_send_msg is the basic function for a process to report a
    message. The argument "code" is an error code for the particular message.
    The error code may be used to indicate the message characteristics such 
    as the category, group, type and severity of the message. The message code 
    is application specific and interpreted typically by application processes 
    (e.g. the system monitor and/or system manager). A message can be either 
    critical or normal. A critical message is identified by setting the 
    LE_CRITICAL_BIT bit in the "code".

    One can also specify a message verbose level in the "code" by ORing one of
    the following macros, LE_VL0, LE_VL1, LE_VL2 and LE_VL3. A message is
    reported only if the message's verbose level is no larger than the
    process's current verbose level. A message is considered of verbose level 0
    if its VL is not specified. The verbose level of critical messages is
    ignored. Each process has a process VL at any given time. An LE message is
    reported only if its VL is no larger than the process's current VL. When a
    process starts, the process VL is set to 0. LE_set_option can be called to
    reset the process's VL. The process VL can be reset by calling LE_set_vl
    while the process is running.

    Three bits of "code" are reserved and interpreted by LE. LE_CRITICAL_BIT
    bit is used for identifying a critical message. Two other bits, LE_VL_MASK,
    are used for specifying the message verbose level. Other bits are defined
    and used by the applications.

    The second argument "format" and the following variable list of arguments
    are used for generating a user ACSII text message like printf does. The
    text message is normally prepared for human interpretation. "format" can be
    NULL or an empty string if there is no additional information except the
    "code". The "text" field generated by the argument "format" and the
    following variable list of arguments, including the task name lable, must
    be no longer than LE_MAX_MSG_LENGTH (256) - 1. If this condition is not
    satisfied, the message is truncated. If the format is "%ms", LE_send_msg
    splits multiple line strings. For example, LE_send_msg (0, "%ms", "Line
    1\nLine 2\n") generates two LE messages: "Line 1" and "Line 2". The LE size
    limit applies to each line in this case.

    The LE library adds the following info for each message.

	The message time.
	The process name (or a user-specified label) and, by option, a user 
		provided instance number.
	The process ID (critical messages only).
	The source file name and line number, from where an LE message is sent
		(critical messages only).

    Because LE messages are stored on the local host, the host name is not 
    stored in each message.

    The Linear Buffer file is used for LE messages because it has controlled
    size and older messages are expired automatically. The LB is convenient
    for storing binary messages of variable sizes. It also provides the
    desired data persistency and access efficiency. Optionally one can use a
    plain file, instead of an LB, for storing the log messages. Refer to 
    LE_set_option (use plain log file).

    Each message received by LE_send_msg are stored in an LE file. The file
    name is "LE_name.log" where, if "LE_name" is not set by LE_set_option,
    "LE_name" is the process name. If a task is running in multiple instances,
    each instance can use its own LE file in which case the file name is
    LE_name.instance_number.log. An instance number can be specified through
    calling LE_set_option (). It is seen from the above that each process uses
    its own LE file by default. This protects the LE messages from being
    flushed out by other processes that write excessive numbers of messages
    into the same LE file.

    All LE files are stored in a directory specified by the environmental
    variable LE_DIR_EVENT. An example of the LE_DIR_EVENT is
    "/users/orpg/log:10000". Note that LE_DIR_EVENT defines both the directory
    and an event number separated by ":". The event number is used for dynamic
    verbose level control. If LE_DIR_EVENT is not defined, the LE messages are
    sent to "stderr" and no dynamic verbose level control is supported. If
    LE_DIR_EVENT is defined but not correctly defined, LE_init will return an
    error code. If the application, ignoring the error return, chooses to
    continue, the LE messages are directed to "stderr". If the event part is
    not defined in LE_DIR_EVENT, no dynamic verbose level control is supported.

    The LE messages written to the LB are in a binary data structure format
    (described later in this man-page). Binary format is more convenient for
    machine interpretation and more efficient in operational execution. LE
    messages can be displayed/monitored by a tool called "lem" (LE monitor).
    Refer to its man-page for further details.

    LE_init initializes the LE service. It sets up the message label and the LE
    file name, creates the directory for LE LB if needed, creates/opens the LE
    LB and registers the verbose level event. If LE_init is not called, the LE
    messages will go to the "stderr", the label part in the ASCII format field
    will be missing. LE_init can be called multiply but it does not do anything
    if the LB is already successively opened in a previous call to LE_init.
    LE_init returns 0 on success or a negative error code as defined in le.h.
    If environmental variable LE_DIR_EVENT is not defined, LB_init returns 0
    and the LE will send all messages to the "stderr" port. LE_init redirects
    all MISC_log message to LE upon opening the LE LB.

    Note that, when LE_init returns with an error message, the task can choose
    to continue execution. In cases of LE_ENV_DEF_ERROR, LE_DUPLI_INSTANCE and
    LE_OPEN_LB_FAILED the LE messages will go to the "stderr" port because the
    LB is not accessible. A task, that is designed for running in an
    operational environment, should probably terminate upon detecting an
    LE_init error.

    LE_set_option sets various LE options according to "opt_name":

	LE_set_option ("instance", int instance) - Sets the process instance 
	number. The default is no instance. Must be set before the first call 
	to LE_init.

	LE_set_option ("label", char *label) - Sets the label; The default is 
	the process name, if passed to LE_init, or "" otherwise. Must be set 
	before the first call to LE_init. Cannot be reset after first set.

	LE_set_option ("LE name", char *name) - Sets the LE LB name; The
	default is the process name, if passed to LE_init. Must be set before
	first call to LE_init. Cannot be reset after first set. If not defined,
	LE_init fails and LE goes to "stderr".

	LE_set_option ("LB type", int type) - Sets the LB type. Can be an OR of
	LB type macros. The default is 0. Must be set before first call to
	LE_init. Cannot be reset after the first set.

	LE_set_option ("LB size", int size) - Sets the maximum number of
	message of the LE LB. The default is 300. Must be set before the first
	call to LE_init. Cannot be reset after the first set.

	LE_set_option ("verbose level", int vl) - Sets the current verbose
	level to "vl". The default level is 0. It returns the previous process 
	VL. If "vl" < 0, LE_set_option returns the process verbose level 
	without changing it.

	LE_set_option ("set foreground") - Directs LE messages to go to the
	stderr instead of the LE LB.

	LE_set_option ("also stderr", int yes) - Turns on ("yes" = 1) or off
	("yes" = 0) the feature of sending the LE messages to the stderr in
	addition to the LE LB.

	LE_set_option ("LE disable", int yes) increments, if "yes" = 1, or
	decrements, if "yes" = 0, the LE disable level. If the LE disable level
	is greater than 0 and the code is not in the EN callback, LE_send_msg
	is disabled (it does nothing). When LE is disabled, MISC_log is also
	disabled. This returns the current LE disable level after this call.
	Make sure that LE disable level decrementing is paired well with
	incrementing.

	LE_set_option ("use plain log file") - Uses a plain file, instead of
	an LB, for storing the log messages.

    LE_log is a simplified interface for LE_send_msg. It uses code 0 to call
    the latter.

    LE_set_vl sets the VL of the process "pid" on host of IP address "host_ip"
    to level "new_vl". All arguments are in local byte order. A process's
    verbose level can be changed by receiving a VL change event. The VL change
    event number is defined in LE_DIR_EVENT. The message format is defined in 
    le.h. LE_set_vl posts such a event. Note that one must first call LE_init 
    before calling LE_set_vl.

    void LE_set_callback (void (*callback) (char *, int)) registers a user
    callback function which will be called when an LE message is reported. The
    callback function has the following interface:

	void (*callback) (char *msg, int msg_len);

    The first argument is a pointer to the LE message in LE_message or
    LE_critical_message format and "msg_len" is the total length of the
    message. An application can register a callback function for additional
    processing of the LE messages.

    LE_dirpath returns, in "buf" of size "buf_size", the LE directory. The 
    return value is the string length of the dir on success of a negative error
    code. The dir does not end with "/". LE_fd returns the LB file desriptor of
    the LE.

    Critical messages use the following structure:

	typedef struct {
	    unsigned int code;		/* msg code */
	    time_t time;		/* msg generation time */
	    int pid;			/* process id */
	    int n_reps;			/* number of msg repetitions */
	    int line_num;		/* the source line number */
	    char f_name[LE_SOURCE_NAME_SIZE];
					/* the source file name */
	    char pad[3];		/* not used */
	    char text[1];		/* user text msg */
	} LE_critical_message;

    Normal messages uses the following structure:

	typedef struct {
	    unsigned int code;		/* msg code */
	    time_t time;		/* msg generation time */
	    int n_reps;			/* number of msg repetitions */
	    char pad[3];		/* not used */
	    char text[1];		/* user text msg */
	} LE_message;

    Field "text" is a NULL terminated user text message. Field "n_reps" will 
    be explained later. "f_name" and "line_num" are the source file name and 
    the line number from where LE_send_msg is called. Note that the "f_name" 
    field has a fixed length. If the file name is too large to fit in, it is 
    stored as "first_part*last_part", where first_part and last_part are 
    respectively the first and the last parts of the file name.

    When a message is written to the "stderr" port, it is converted to 
    the following ASCII text format:

	mn/dd/yy hh:mm:ss label: user text (%d repeats) - f_name:line_n

    where "label" is the process name if not otherwise specified with
    LE_set_option, "user text" is the user's text message, "mn/dd/yy hh:mm:ss"
    is the message time, "f_name" and "line_n" are respectively the "f_name"
    and "line_num" fields in LE_critical_message. They are available only for
    critical messages. The date field, mn/dd/yy, is printed out only for the
    first message and when it is different from that of the previous message.
    "%d repeats" prints the "n_reps" field. This field is printed only if
    n_reps > 1.

    LE library suppresses repeated messages. For a sequence of consecutive
    repeated messages, the first 10 are always sent out. The remaining are sent
    in samples. A sample of consecutive repeated messages is sent once in a
    second. The "n_reps" field stores the cumulative number of consecutive
    repetitions of the LE_send_msg calls after the previous sample. The last
    one in the sequence is always sent as a sample such that one can always
    know exactly how many LE_send_msg calls in the entire sequence. LE library
    does not suppress critical messages.
    
    The LE controls the number of critical messages that can be sent in a given
    time period. If more than 10 critical messages are sent in a second, the LE
    will suspend the execution for about 20 MS before processing the next such
    message.

    LE_send_msg is implemented as a reentrant function. I.e. it can be called
    in a interrupt handler function. If a LE_send_msg call is interrupted
    by a function call that also calls LE_send_msg, the message of the second
    LE_send_msg is stored internally. The stored message will then be processed
    after the interrupt function returns and the first LE_send_msg completes.
    LE allocates certain buffer for storing messages in case of reentry. If 
    too many LE messages sent from an interrupt function, the buffer may full.
    In this case the additional messages are discarded and a special critical
    LE message will be generated to replace each lost message.

    The LE_send_msg function blocks the following signals in its critical
    section when reentry happens: SIGTERM, SIGINT, SIGIO, SIGUSR1, SIGUSR2
    and SIGALRM. If a processes is killed while it is in processing reentered
    LE_send_msg, stored LE messages may be lost. To guarantee all LE messages 
    are not lost, one can call LE_terminate () before process termination. If
    LE_terminate is called with argument "term_func" = NULL, the process will
    exit with "status" after all pending LE messages are processed. If 
    "term_func" is not NULL, function term_func is called instead of process
    termination. For example, in the process termination callback function,
    we do the following:

	LE_send_msg (0, "%s", "process is exiting ...");
	LE_terminate (NULL, status);
	return;

    instead of 
	
	LE_send_msg (0, "%s", "process is exiting ...");
	exit (status);


    The following functions will be phased out in the future:

    char *LE_gen_text (const char *format, ...);
	The only place it is used is in le_logerr.c.

    void LE_instance (int instance_number);

    int LE_create_lb (char *argv0, int n_msgs, int lb_type, int instance);

    int LE_local_vl (int new_vl);

    void LE_set_foreground ();

    void LE_also_print_stderr (int yes);


    LE_also_print_stderr is the same as LE_set_option ("also stderr", 1[0]).

    LE_set_foreground is the same as LE_set_option ("set foreground").

    LE_local_vl is the same as LE_set_option ("verbose level", new_vl).

    LE_create_lb sets options "LE name", "LB size", "LB type" and "instance".
    This function is to be replaced by LE_set_option.

    LE_instance is the same as LE_set_option ("instance", instance_number).

    LE_gen_text generates the text message in term of "format" and other
    arguments. It returns a pointer to the text. The caller should not free the
    pointer. LE_gen_text is designed to be used by LE message macros.

EXAMPLE

    #include <infr.h>

    #define GL_STATUS	(0x10000000 | LE_CRITICAL_BIT)
    #define GL_ERROR	(0x20000000 | LE_CRITICAL_BIT)
    #define GL_INFO	0

    main (int argc, char **argv) {

	......

	if ((ret = LE_init (argc, argv)) < 0) {
	    fprintf (stderr, "LE_init failed (ret %d)", ret);
	    exit (1);
	}

	fd = socket (...);

	if (fd < 0) {
	    LE_send_msg (GL_ERROR, "socket failed (errno %d)\n", errno);
	    exit (1);
	}

	......
    }

    The following section sets the LE LB size to 500 and the LB type is 
    "LB_SINGLE_WRITER"

	LE_set_option ("LB size", 500);
	LE_set_option ("LB type", LB_SINGLE_WRITER);
	if ((ret = LE_init (argc, argv)) < 0) {
	    fprintf (stderr, "LE_init failed (ret %d)", ret);
	    exit (1);
	}


    The following section sets the LE LB name to "hci" and the message label to
    "hci_nb". The LE messages go to file "hci.log".

	LE_set_option ("label", "hci_nb);
	LE_set_option ("LB name", "hci);
	if ((ret = LE_init (argc, argv)) < 0) {
	    fprintf (stderr, "LE_init failed (ret %d)", ret);
	    exit (1);
	}


SEE ALSO
    lem(1), lb(3)

NOTES



	


