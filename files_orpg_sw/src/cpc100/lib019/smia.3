
NAME
    SMIA_serialize, SMIA_deserialize, SMIA_set_smi_func, SMIA_free_struct,
    SMIA_bswap_output, SMIA_bswap_input, SMIA_is_pvss_struct

SYNOPSIS
    #include <infr.h> or #include <smi.h>

    int SMIA_serialize (char *type, void *c_data, 
				char **serial_data, int c_data_size);

    int SMIA_deserialize (char *type, char *serial_data, 
				char **c_data, int serial_data_size);

    void SMIA_set_smi_func (SMI_info_t *(*smi_get_info)(char *, void *));

    void SMIA_free_struct (char *type, char *c_data);

    int SMIA_bswap_output (char *type, void *data, int data_len);

    int SMIA_bswap_input (char *type, void *data, int data_len);

    int SMIA_is_pvss_struct (char *type);

DESCRIPTION

    The SMIA (Sturct Meta Info Applications) module contains routines that
    support applications that use the SMI info generated by smipp. In order to
    use functions in this module, one needs to first call SMIA_set_smi_func to
    set the right function that is to be used for getting the SMI info. Note
    that the default SMI info function is SMI_get_info. Other function names
    may be used depending on the environment where the application is
    developed. See smipp man-page for further details. SMIA sends error 
    messages through MISC_log if the SMI is not available for a type.

    SMIA_serialize serializes C struct "c_data" of type "type". The serialized
    data is returned with "serial_data". The caller should free the returned
    pointer if it is not NULL and it is not identical to "c_data". Argument
    "c_data_size" is used only for type 3 data structure (explained latter in
    this page). It specifies the total size of the input structure.
    SMIA_serialize returns, on success, the size (number of bytes) of the
    serialized data. It returns a negative error code on failure.

    SMIA_deserialize deserializes "serial_data" of length "serial_data_size" to
    create C struct of "type". The created struct is returned with "c_data".
    The caller should free the returned pointer (and any pointer inside the
    struct) if it is not NULL and it is not identical to "serial_data".
    SMIA_deserialize returns, on success, the number of bytes used in
    "serial_data". It returns a negative error code on failure.

    Serialized data can be deserialized on a host of different byte order.
    SMIA_serialize and SMIA_deserialize, however, do not perform byte swapping.
    After deserialization, any sizeof_* field used as array size for type 2 as
    explained in the next, is in local byte order format. All other fields are
    not byteswapped.

    Three types of data structures are supported:

    1. Normal C structures that do not have any pointer fields.

    2. C structures with defined ways of using pointers. This type of C 
    structure is called PVSS (Pointer Variable Size Struct) here. A PVSS can
    contain the following pointer fields:

	a. Pointers with explicitly specified size. An example of such PVSS is

	typedef struct {
	    int sizeof_a_field;
	    short *a_field;
	} example_t;

	An pointer field with explicitly specified size can be of any primitive
	type or user defined type. Here it is a short. Such a field is assumed 
	to be a pointer to an array of the typed data. The size of the array 
	must be specified explicitly in the field that proceeds the pointer
	fields. The size field must of "int" type and use the name of 
	"sizeof_pfname", where "pfname" is the name of the pointer field. The 
	unit of field size is the type size. For example, in the above case,
	"sizeof_a_field" must be the number of shorts in array pointer to by
	"a_field".

	b. "char *" pointers without explicitly specified size. Such fields are
	assumed to be null terminated character strings.

    The following are valid PVSS structures (Note that a PVSS field can be
    of type of another PVSS):

	typedef struct {
	    char *string;		/* null terminated string */
	    int sizeof_a_field;
	    short *a_field;		/* explicitly sized field */
	    float float_field;
	} example1_t;

	typedef struct {
	    example1_t array[2];
	    int some_field;
	    char some_string[32];
	    int sizeof_another_field;
	    example1_t *another_field;	/* explicitly sized field */
	    char *string;		/* null terminated string */
	    int sizeof_a_field;
	    short *a_field;		/* explicitly sized field */
	} example2_t;

    3. C structures with VSS (Variable Size Struct) extentions (See smipp
    man_pages). This type of VSS is a combination of multiple C structures. The
    size and location of each sub-structure are calculated based on the field
    values of the main structure. Pointer fields are not allowed. Struct with
    field of this type is not supported.

    Supporting type 2 provides convenience for the application to deal with 
    variable size data structures. Type 3 is useful for supporting externally 
    defined data.

    To increase efficiency, the serialized data of any struct or struct field
    that does not contain any pointer is simply a copy of the binary C struct 
    data. All pointer fields are dereferenced and stored sequencially. 
    Data alignment is not considered. Thus one should not try to derectly 
    dereference the serialized data.

    For types 1 and 3, because serialized data is identical to the original
    data, SMIA_serialize returns pointer value "c_data" as "serial_data". If
    byte swap is needed, it performs in-place byte swapping. The caller is
    responsible for passing a correctly constructed "c_data". Because the
    returned pointer is "c_data", it does not need to be freed.
    SMIA_deserialize works in a similar way except that the data boundary is
    checked in doing byte swapping.

    For types 1 and 2, SMIA_serialize returns the length of the serialized 
    data. For type 3, It returns the size of the main struct (not the total 
    size of the VSS).

    SMIA_free_struct frees all pointers in struce "c_data" of "type" and 
    "c_data" itself. It frees "c_data" for structs of type 1 and 3. Be
    careful, however, that if any pointer field is not a malloced pointer, 
    this function cannot be applied.

    SMIA_bswap_output and SMIA_bswap_input perform byte swapping on data
    pointed to by "data" and of type "type". "data_len" is the length of the
    data, in number of bytes, in the buffer pointed by "data". This is used for
    boundary checking while performing the byte swapping. No byteswap is
    performed beyond the boundary. If "data_len" is zero, data boundary
    checking is disabled. The two functions are identical for types of 1 and 2
    and can be applied to "data" of any byte order. For type 3, "data" must be
    in internal byte order for SMIA_bswap_output and, for SMIA_bswap_input,
    "data" must be in the byte order that is different from the internal byte
    order. Any sizeof_* field that is used for array size in type 2 is not
    byteswapped.

    The two functions return the size of "type" on success or a negative
    error code on failure.

    SMIA_is_pvss_struct (char *type) returns TRUE (non-zero) if type "type" is
    a PVSS struct or FALSE (zero) otherwise. It returns an negative error code
    on failure. A PVSS structure needs serialization.

    Performance of SMIA functions is a consideration in implementation. Hard to
    computer info is stored for latter look up.

EXAMPLE


SEE ALSO
    smipp(1)

NOTES







