
NAME
    smipp - Struct Meta Info Preprocessor

SYNOPSIS
    smipp [options] file_names

DESCRIPTION
    smipp is a preprocessor that generates source code for functions that 
    provide C struct meta info (SMI).

    The meta info can be used for developing generic byte swap functions,
    generic binary data display routines and GUIs, C-JAVA interface,
    struct-to-struct copy routines (e.g. for data base schema), routines for 
    initializing binary data struct from ASCII files, data serialization 
    routines. It can also be extended for implementing generic RPC interface.

    smipp accepts files with suffix .m or .h, which are C header files with
    additional SMI instructions in comment. Using suffix .m may be convenient
    in the makefile. smipp generates C source code file named fname.c from
    fname.m (or fname.h). smipp accepts multiple input files (.m or.h files).

    The C file generated by smipp contains functions that return the meta info
    about the specified C data structures. It should then be compiled and
    linked into either applications or libraries. A function is generated for
    each specified struct. Each function has a comment at its beginning stating
    the location (source file name and line number) of the original struct
    definition. If the smipp generated code does not compile, check the
    original struct definition code.

    smipp recorgnizes smipp instructions in C comment. Each instruction starts
    with a SMI keyword. The following smipp keywords are currently used:

	SMI_struct - Specifies a struct which meta info will be available.

	SMI_function - Specifies a function name that will be used for 
	retrieving the meta info.

	SMI_vss_field - Specifies a variable size structure to be explained 
	later.

    Multiple smipp instructions can be put in the same comment section.

    Each SMI_struct specifies a struct whose meta info is required. The syntax
    is

	/* SMI_struct name id;	*/

    where "name" is a struct or a typedef name. Examples are "struct my_struct"
    and "my_type". "id", in the format of "major.minor" where major and minor
    are two integer constants or macros that define integer constants, assigns
    a unique ID for the struct and the SMI can then be retrieved with the ID
    instead of the name. "major" and "minor" must be non-negative. "minor" is
    optional in the "id" field. "id" field is optional in a SMI_struct
    instruction. An SMI_struct instruction must be terminated by character ';'.

    Key word SMI_function specifies the function names for retrieving the SMI.
    The syntex is 

	/* SMI_function func_name; */

    where "func_name" is the core of the file names. An SMI_struct instruction 
    must be terminated by character ';'. Three functions are generated for 
    accessing the SMI:

	SMI_info_t *func_name (char *name, void *data);
	char *func_name_type_by_id (int major, int minor);
	int func_name_get_all_ids (int **majors, int **minors, char ***types);

    The first function accepts a struct name or a typedef name and returns a
    struct pointer containing the SMI of the struct. The last argument is used
    to pass a pointer to the struct data which are required for certain
    variable size structs. For normal C struct the second argument is not used.
    The function returns NULL if the SMI for the the struct is not available.
    If "data" is required and it is passed in as NULL, the function will return
    a SMI_info_t struct with incomplete per-field info.

    The second function accepts the struct IDs (major and minor), specified
    through SMI_struct, and returns the struct name which can then be used as
    the first argument for calling the first function. It returns NULL if the
    struct is not found. It searches for the exact match of both major and
    minor IDs if "minor" >= 0. If not match is found for "minor", the first
    struct of unspecified minor ID is returned. If "minor" == -1, the first
    struct of unspecified minor ID is returned. This function currently uses a
    linear search.

    The third function returns pointer to arrays of all major IDs, minor IDs
    and struct names with arguments "majors", "minors" and "types"
    respectively. It returns the size of these arrays. The arrays are
    real-only.

    "func_name" call with "name" = NULL is used to switch on/off the byte swap 
    function on field values in "data" that are needed for calculating SMI 
    (for VSS explained later). func_name (NULL, (void *)1) turns on the byte 
    swapping and func_name (NULL, (void *)0) turns it off. The default is off.

    If key word SMI_function is not found, the following function names are
    used: SMI_get_info, SMI_get_info_type_by_id and SMI_get_info_get_all_ids.
    Function prototypes for these two functions are in smipp.h. If user defined
    function names are used, one has to provide the appropriate function
    prototypes as well. Mupltiple definitions with SMI_function is not allowed.

    SMI_info_t, defined in smipp.h, has the following fields:

	typedef struct {		/* struct of meta info */
	    char *name;			/* name of the struct */
	    int size;			/* size of the struct */
	    short n_fields;		/* number of fields including VSF */
	    short n_vsfs;		/* number of variable size fields */
	    SMI_field_t *fields;	/* pointer to the field array */
	    void *ci;			/* custom info */
	} SMI_info_t;

    where "fields" is an array of the following:

	typedef struct {		/* struct of meta info */
	    char *name;			/* field name */
	    char *type;			/* field type */
	    int n_items;		/* number of items (array size) */
	    int size;			/* size of each item */
	    int offset;			/* offset of the first item */
	    void *ci;			/* custom info */
	} SMI_field_t;

    "size" in SMI_info_t is the value of sizeof (name). i.e. the size of the
    C structure (not taking into account of any variable size fields). "ci"
    is a pointer reserved for the caller to put additional data.

    The "type" for each fields is a character string such as, for example,
    "int", "unsigned short", "int * *", "My_type *" or "int * ( * ). The last
    one is a function pointer. The function returns "int *". Note that the
    function argument types are not available for the moment. Each type is
    resolved to its original type if possible. For example, if we have, 

	typedef unsigned int type1_t;
	typedef type1 * type2_t;

    Then the type of struct field "type2_t f;" is returned as "unsigned int *".

    smipp generates SMI for all structs used by structs specified by 
    SMI_struct. This is performed recursively so one can have complete SMI
    for each struct. smipp generates SMI code only once for each struct.

    The caller should not try to free the returned SMI_info_t structure.

    Unnamed struct and union are not processed. It returns "struct" and "union"
    as the type. We can, in the future, further resolve embedded unnamed struct
    fields, e.g. the field name will be f1.f2, where f1 is the struct field
    name and f2 is the field name inside the struct. For union, additional
    SMI instructions are needed to resolve types on the run time (e.g. using
    data field value).

    By option (option -d) smipp dumps partial SMI info into a specified file.
    The dumped data are SMI, in the format of SMI_data_info_t as defined in
    smipp.h, for all structs specified by SMI_struct. The SMI_data_info_t
    binary structure are stored one after another. Note that only field names
    and types are available in SMI_data_info_t. Array sizes are available for
    explicitly specified fields. It them are not available, value 0 is put in 
    the file.

    smipp supports variable size structs (VSS) in several ways. smipp key words
    SMI_vss_field and SMI_vss_size are used for this purpose. SMI_vss_field
    specifies a variable size field after the normal fields. A variable size
    field is an array of another type. The location and size of the array is
    calculated based on data in the normal fields. The syntax for SMI_vss_field
    is either

	/* SMI_vss_field type name [n_items] (offset); */

    which is called the long form or

	/* SMI_vss_field [n_items]; */

    which is the short form. "type" is any C type and "name" is any C
    identifier. "n_items" and "offset" are any C expressions, that result in an
    integer, for calculating the array size and offset of the field. Word
    "this" is reserved for indicating the current struct. Note that the array
    size is put in [] and offset is put in () after the array size. Multiple []
    specification is not allowed.

    The syntax for SMI_vss_size is

	/* SMI_vss_size type_size; */

    where "type_size" is any C expression that evaluates an integer size of the
    structure. "type_size" may depend on any of the normal field values ("this"
    is used again). SMI_vss_size specification can appear on anywhere inside 
    the structure definition. The first is used if it is defined multiply.

    The following are supported ways of specifying VSS.

    If a field (must be the last field) is an array of variable size
    (programmer appends additional data to the last field), one can add the
    variable array size information with short form SMI_vss_field, for example:

	struct my_struct {
	    int f1;
	    int size;
	    My_struct4 f2[1]; /* SMI_vss_field[this->size] */
	}

    Here the array size of "f2" is the value of field "size" of this struct. 

	struct my_struct {
	    int f1;
	    char f2[1]; /* SMI_vss_field[strlen (this->f2) + 1] */
	}

    In this example, field "f2" is a NULL terminated string.

    Multiple variable size fields can be specified with the long form 
    SMI_vss_field:

	struct my_struct1 {	/* SMI_vss_size this->f1 */
	    int f1;
	    int offset;
	    int size;
	    int size1;
	    /* SMI_vss_field My_struct2 f2[this->size] 
			(ALIGNED_SIZE (sizeof (struct my_struct1))) */
	    /* SMI_vss_field int f3[this->size1] (this->offset) */
	}

    This VSS struct has 6 fields. The last two fields are "f2" of type
    My_struct2 and "f3" of type "int". They are all arrays. Otherwise, they
    would not be of variable size. The array sizes are values of fields "size"
    and "size1" respectively. The starting offset of field "f2" is calculated
    based on the size of this struct (C struct, not VSS). Function (or macro)
    ALIGNED_SIZE must defined. The starting offset of field "f3" is the value
    of field "offset". The total size of the VSS is given by the value of "f1".

    The two comment lines in the above example can also be written as 

	/*  SMI_vss_field My_struct2 f2[this->size] (this->off)
	    SMI_vss_field int f3[this->size1] (this->off1)	*/

    The implementation is efficient for dealing with large amount of 
    structures. SMI static information is stored in read-only data segments.
    Binary search is used for look up SMI by struct name.

OPTIONS
    -c	cpp_name
	Specifies an alternative preprocessor other than gcc.

    -t	Runs in debug mode. Intermediate files are not removed.

    -o	cpp_options
	Specifies preprocessor options such as the directory for include files.

    -f	cpp_flags
	Specifies alternative preprocessor flags other than "-E -C".

    -d	data_file_name
	Causes smipp to dumps data to file "data_file_name".

EXAMPLES
    Example 1: smipp -o "-I../include -I." t.m
	Processes file "t.m" to generate "t.c" which contains the function for
	retrieving SMI. Note that the way of specifying the C preprocessor 
	options.

    Example 2: smipp -t -o "-I../include -I." -d smi_file t.m
	The same as 1 except that running in debug mode and partial SMI data
	is written to file "smi_file".

    The following is an example .m file.

	#include <stdio.h>
	#include <lb.h>
	
	typedef int **(*T1) ();
	
	struct my_struct {
	    LB_id_t id;
	    unsigned int ui[3] [ 4];
	    int (*ghgghj[3]) ();
	    LB_info *info;
	    T1 jfjfkf;
	};
	typedef struct my_struct My_type;
	
	typedef unsigned int ** T2;
	typedef uint_t T3;
	
	/*
	SMI_struct My_type ORPGDAT_RDA_COMMAND;
	SMI_struct T1   1236;
	SMI_struct T2;
	SMI_struct T3;
	SMI_struct T3;
	SMI_struct sigset_t;
	SMI_struct LB_wait_list_t;
	SMI_struct LB_status;
	SMI_struct LB_info;
	
	SMI_function ORPG_type_info;
	*/


    Note that in this example, the SMI function name "ORPG_type_info". T1, T2 
    and T3 are not structs and smipp will not generate meta info for them. 
    Functions will be generated for meta info of structs My_type, sigset_t, 
    LB_wait_list_t, LB_status, LB_info, LB_attr and LB_check_list. The last 
    two are dependent structs.

EXIT STATUS
    0:		Terminated normally. 

    non-zero:	Terminated because an error was detected.

SEE ALSO
