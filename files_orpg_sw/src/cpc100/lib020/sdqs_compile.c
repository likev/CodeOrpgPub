
/******************************************************************

	This is the sdmqm module for preparing the dynmically 
	loadable module.
	
******************************************************************/
/*
 * RCS info
 * $Author: jing $
 * $Locker:  $
 * $Date: 2005/04/15 19:36:00 $
 * $Id: sdqs_compile.c,v 1.7 2005/04/15 19:36:00 jing Exp $
 * $Revision: 1.7 $
 * $State: Exp $
 */


#include <config.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include <infr.h> 
#include <smi.h> 

#include "sdqs_def.h"

#define TMP_BUF_SIZE 256

extern int Verbose;

struct env_struct {
    int n_incs;			/* number of include files */
    char *incs;			/* include file names */
    char *compiler;
    char *smipp_options;
    char *compile_options;
    char *work_dir;
};
typedef struct env_struct envs_t;

static envs_t Envs;

static int N_tables = 0;	/* number of sdb tables */
static table_t *Tables = NULL;	/* array of sdb tables */

struct macro_list {		/* macro list item */
    char *macro;		/* pointer to the macro */
    struct macro_list *next;
};
typedef struct macro_list macro_list_t;

static macro_list_t *Macros = NULL;	/* list of macros to be resolved */

static int Is_separator (char c);
static int Read_data_input (data_input_t **dis);
static int Read_index_tree (index_tree_t **its);
static void Print_config_info ();
static void Create_tm_file (char *name);
static void Read_smipp_data (char *name);
static void Verify_sdb_struct (table_t *table, int fd);
static void Generate_get_record (FILE *fl, table_t *table);
static void Generate_c_source (char *name);
static void Generate_get_misc (FILE *fl, table_t *table);
static void Generate_byte_swap (FILE *fl, table_t *table);
static void Generate_free_record (FILE *fl, table_t *table);
static int Is_a_valid_field (char *field_name, SMI_data_info_t *smi);
static int Get_field_type (SMI_data_info_t *smi, char *fname);
static void Generate_get_macro (FILE *fl);
static void Add_macro (char *name);
static char *Append_string (char *str1, char *str2);
static char *Get_default_compile_options (char *compiler);
static char *Get_config_str (table_t *table);
static char *Archive_string (char *str);
static char *Get_all_table_names ();
static char *Read_smi_file (char *type, int fd);


/******************************************************************

    Returns the SDB table struct array.

******************************************************************/

int SDQSC_get_sdb_tables (table_t **tables) {
    *tables = Tables;
    return (N_tables);
}

/******************************************************************

    Generates table dependent code for dynamic loading.

******************************************************************/

void SDQSC_generate_code () {
    char tm_fname[TMP_BUF_SIZE], smipp_data_fname[TMP_BUF_SIZE];
    char src_fname[TMP_BUF_SIZE];
    char cmd[TMP_BUF_SIZE * 5];

    if (strlen (Envs.work_dir) + 32 > TMP_BUF_SIZE) {
	LE_send_msg (GL_ERROR, "work dir (%s) too long\n", Envs.work_dir);
	exit (1);
    }
    sprintf (tm_fname, "%s/%s", Envs.work_dir, "sdqs_tmp.m");
    Create_tm_file (tm_fname);

    /* invoke smipp */
    sprintf (smipp_data_fname, "%s/%s", Envs.work_dir, "sdqs_data");
    sprintf (cmd, "smipp -d %s -c %s -o \"%s\" %s", 
	smipp_data_fname, Envs.compiler, Envs.smipp_options, tm_fname);
    LE_send_msg (LE_VL1, "run: %s\n", cmd);
    if (system (cmd) != 0) {
	LE_send_msg (GL_ERROR, "smipp failed\n");
	exit (1);
    }

    Read_smipp_data (smipp_data_fname);

    /* generate c source file and compile it */
    tm_fname[strlen (tm_fname) - 1] = 'c';
    sprintf (src_fname, "%s/%s", Envs.work_dir, "sdqs_src.c");
    Generate_c_source (src_fname);
    sprintf (cmd, "%s %s %s %s", 
		Envs.compiler, Envs.compile_options, src_fname, tm_fname);
    LE_send_msg (LE_VL1, "run: %s\n", cmd);
    if (system (cmd) != 0) {
	LE_send_msg (GL_ERROR, "creating DLL failed\n");
	exit (1);
    }
}

/******************************************************************

    Generates the c source file for dynamically loaded functions.

******************************************************************/

static void Generate_c_source (char *name) {
    FILE *fl;
    char *incs;
    int i;

    fl = fopen (name, "w");
    if (fl == NULL) {
	LE_send_msg (GL_ERROR, "creating file (%s) failed\n", name);
	exit (1);
    }

    fprintf (fl, 
	"\n%c*** This file is generated by sdqs ***%c\n\n", '/', '/');

    fprintf (fl, "#include <stdio.h>\n");
    fprintf (fl, "#include <unistd.h>\n");
    fprintf (fl, "#include <stdlib.h>\n");
    fprintf (fl, "#include <string.h>\n");
    fprintf (fl, "#include <malloc.h>\n");
    fprintf (fl, "#include <infr.h>\n");
    incs = Envs.incs;
    for (i = 0; i < Envs.n_incs; i++) {
	fprintf (fl, "#include <%s>\n", incs);
	incs += strlen (incs) + 1;
    }
    fprintf (fl, "\n");

    for (i = 0; i < N_tables; i++) {
	Generate_get_record (fl, Tables + i);
	Generate_byte_swap (fl, Tables + i);
	Generate_get_misc (fl, Tables + i);
	Generate_free_record (fl, Tables + i);
    }
    Generate_get_macro (fl);

    fclose (fl);
}

/******************************************************************

    Generate the function for returning macro values. Works only 
    for integer macros.

******************************************************************/

static void Generate_get_macro (FILE *fl) {
    macro_list_t *m;

    fprintf (fl, "\nchar *%s (char *name) {\n", 
					GET_MACRO_FUNC_NAME);
    fprintf (fl, "    static char buf[128];\n\n");
    fprintf (fl, "    buf[0] = ' ';\n");

    fprintf (fl, "    if (strcmp (\"SDQS_port\", name) == 0)\n");
    fprintf (fl, "	return (\"%s\");\n\n", SDQSM_get_port ());

    fprintf (fl, "    if (strcmp (\"SDQS_sdb_names\", name) == 0)\n");
    fprintf (fl, "	return (\"%s\");\n\n", Get_all_table_names ());

    m = Macros;
    while (m != NULL) {
	fprintf (fl, "    if (strcmp (\"%s\", name) == 0) {\n", m->macro);
	fprintf (fl, "	buf[127] = (char)0;\n");
	fprintf (fl, "	sprintf (buf, \"%cd\", %s);\n", '%', m->macro);
	fprintf (fl, "	return (buf);\n");
	fprintf (fl, "    }\n");
	m = m->next;
    }

    fprintf (fl, "    return (NULL);\n");
    fprintf (fl, "}\n");
}

/******************************************************************

    Generate the function for returning field offset, sizeof (sdb_t)
    and sizeof (src_t) ("field_name" are "sizeof (sdb_t)" and 
    "sizeof (src_t)" respectively). The function also verifies the
    query field macro. It is not a well defined macro, -2 is returned.
    -1 is returned if the name is not found.

******************************************************************/

static void Generate_get_misc (FILE *fl, table_t *table) {
    SMI_data_info_t *smi;
    int i;

    fprintf (fl, "\nint %s (char *name, void *type) {\n", 
			SDQSC_get_func_name (GET_MISC_FUNC, table));
    fprintf (fl, "    static int n_gf_names = %d;\n", table->n_qfs);
    SDQSC_convert_chars (table->n_qfs - 1, table->qfs, '\0', ':');
    fprintf (fl, "    static char *qf_names = \"%s\";\n", table->qfs);
    SDQSC_convert_chars (table->n_qfs - 1, table->qfs, ':', '\0');

    SDQSC_convert_chars (table->n_qfs - 1, table->types, '\0', ':');
    fprintf (fl, "    static char *qf_types = \"%s\";\n", table->types);
    SDQSC_convert_chars (table->n_qfs - 1, table->types, ':', '\0');

    fprintf (fl, "    %s tmp;\n", table->sdb_t);
    fprintf (fl, "    int off;\n\n");

    fprintf (fl, "    if (strcmp (\"config_info\", name) == 0) {\n");
    fprintf (fl, "	*((char **)type) = \"%s\";\n", Get_config_str (table));
    fprintf (fl, "	return (0);\n\n");
    fprintf (fl, "    }\n");

    fprintf (fl, "    if (strcmp (\"sizeof (%s)\", name) == 0)\n", 
							table->sdb_t);
    fprintf (fl, "	return (sizeof (%s));\n\n", table->sdb_t);
    fprintf (fl, "    if (strcmp (\"sizeof (%s)\", name) == 0)\n", 
							table->src_t);
    fprintf (fl, "	return (sizeof (%s));\n\n", table->src_t);
    fprintf (fl, "    if (strcmp (\"sdb_gf_names\", name) == 0) {\n");
    fprintf (fl, "	*((char **)type) = qf_names;\n");
    fprintf (fl, "	return (n_gf_names);\n");
    fprintf (fl, "    }\n");
    fprintf (fl, "    if (strcmp (\"sdb_gf_types\", name) == 0) {\n");
    fprintf (fl, "	*((char **)type) = qf_types;\n");
    fprintf (fl, "	return (n_gf_names);\n");
    fprintf (fl, "    }\n\n");

    smi = table->smi;
    for (i = 0; i < smi->n_fields; i++) {
	char *fname;

	fname = (char *)smi + smi->fields[i].name_off;
	fprintf (fl, "    if (strcmp (\"%s\", name) == 0) {\n", fname);
	fprintf (fl, 
	    "	off = (unsigned int)&(tmp.%s) - (unsigned int)&tmp;\n", fname);
	fprintf (fl, "	*((int *)type) = %d;\n", Get_field_type (smi, fname));
	fprintf (fl, "	return (off);\n");
	fprintf (fl, "    }\n");
    }

    fprintf (fl, "    return (-1);\n");
    fprintf (fl, "}\n");
}

/******************************************************************

    Converts the first "cnt" characters of "c1" in string "str" to 
    "c2".

******************************************************************/

void SDQSC_convert_chars (int cnt, char *str, char c1, char c2) {
    int i;
    char *p;

    p = str;
    i = 0;
    while (i < cnt) {
	if (*p == c1) {
	    *p = c2;
	    i++;
	}
	p++;
    }
}

/******************************************************************

    Returns the SDQM type of field "fname".

******************************************************************/

static int Get_field_type (SMI_data_info_t *smi, char *fname) {
    int i;

    for (i = 0; i < smi->n_fields; i++) {
	char *name, *type;

	name = (char *)smi + smi->fields[i].name_off;
	if (strcmp (name, fname) != 0)
	    continue;
	type = (char *)smi + smi->fields[i].type_off;
	if (strcmp (type, "int") == 0 ||
	    strcmp (type, "unsigned int") == 0 ||
	    strcmp (type, "long") == 0 ||
	    strcmp (type, "unsigned long") == 0)
	    return (SDQM_QFT_INT);
	if (strcmp (type, "float") == 0)
	    return (SDQM_QFT_FLOAT);
	if (strcmp (type, "short") == 0 ||
	    strcmp (type, "unsigned short") == 0)
	    return (SDQM_QFT_SHORT);
	if (strcmp (type, "char *") == 0)
	    return (SDQM_QFT_STRING);
    }
    return (-1);
}

/******************************************************************

    Generate the function for byte swap sdb record fields.

******************************************************************/

static void Generate_byte_swap (FILE *fl, table_t *table) {
    SMI_data_info_t *smi;
    int i;
    char *ar, *indent;

    fprintf (fl, "\nint %s (char *rec) {\n", 
			SDQSC_get_func_name (BYTE_SWAP_FUNC, table));
    fprintf (fl, "    %s *sdb = (%s *)rec;\n", 
				table->sdb_t, table->sdb_t);

    smi = table->smi;
    for (i = 0; i < smi->n_fields; i++) {
	if (smi->fields[i].n_items > 1) {
	    fprintf (fl, "    int i;\n");
	    break;
	}
    }
    fprintf (fl, "\n");

    for (i = 0; i < smi->n_fields; i++) {
	char *name, *type;

	name = (char *)smi + smi->fields[i].name_off;
	type = (char *)smi + smi->fields[i].type_off;
	if (smi->fields[i].n_items > 1) {
	    fprintf (fl, "    for (i = 0; i < %d; i++)\n", 
					smi->fields[i].n_items);
	    indent = "\t";
	    ar = "[i]";
	}
	else {
	    indent = "    ";
	    ar = "";
	}
	if (strcmp (type, "int") == 0 ||
	    strcmp (type, "unsigned int") == 0 ||
	    strcmp (type, "long") == 0 ||
	    strcmp (type, "unsigned long") == 0)
	    fprintf (fl, "%ssdb->%s%s = INT_BSWAP (sdb->%s%s);\n", 
						indent, name, ar, name, ar);
	if (strcmp (type, "float") == 0)
	    fprintf (fl, "%sFLOAT_BSWAP (sdb->%s%s);\n", indent, name, ar);
	if (strcmp (type, "short") == 0 ||
	    strcmp (type, "unsigned short") == 0)
	    fprintf (fl, "%ssdb->%s%s = SHORT_BSWAP (sdb->%s%s);\n", 
						indent, name, ar, name, ar);
	if (strcmp (type, "char *") == 0)
	    fprintf (fl, 
		"%ssdb->%s%s = (char *)INT_BSWAP ((int)(sdb->%s%s));\n", 
						indent, name, ar, name, ar);
    }

    fprintf (fl, "    return (0);\n");
    fprintf (fl, "}\n");
}

/******************************************************************

    Generate the function for freeing a sdb record.

******************************************************************/

static void Generate_free_record (FILE *fl, table_t *table) {
    SMI_data_info_t *smi;
    char *name, *type;
    int i;

    fprintf (fl, "\nint %s (char *rec) {\n", 
			SDQSC_get_func_name (FREE_RECORD_FUNC, table));

    smi = table->smi;
    for (i = 0; i < smi->n_fields; i++) {
	type = (char *)smi + smi->fields[i].type_off;
	if (strcmp (type, "char *") == 0) {
	    fprintf (fl, "    %s *sdb = (%s *)rec;\n", 
				table->sdb_t, table->sdb_t);
	    break;
	}
    }
    fprintf (fl, "\n");

    for (i = 0; i < smi->n_fields; i++) {
	name = (char *)smi + smi->fields[i].name_off;
	type = (char *)smi + smi->fields[i].type_off;
	if (strcmp (type, "char *") == 0) {
	    fprintf (fl, "    if (sdb->%s != NULL)\n", name);
	    fprintf (fl, "	free (sdb->%s);\n", name);
	}
    }

    fprintf (fl, "    return (0);\n");
    fprintf (fl, "}\n");
}

/******************************************************************

    Generate the function for getting record from the LB message.
    We don't check the source struct: the existance and type of the
    fields needed. We will let the compiler to report it later.
    Note that we cannot check the correctness of the user's data_input
    section anyway. The get_record function returns 0 on success
    or -1 on malloc failure.

******************************************************************/

static void Generate_get_record (FILE *fl, table_t *table) {
    SMI_data_info_t *smi;
    int i;

    fprintf (fl, "\nint %s\n", SDQSC_get_func_name (GET_RECORD_FUNC, table));
    fprintf (fl, "		(char *src, LB_id_t msgid, char *dest) {\n");

    if (table->data_input_func[0] != '\0') {
	fprintf (fl, "    return (%s (src, msgid, dest));\n", 
					table->data_input_func);
	fprintf (fl, "}\n");
	return ;
    }

    fprintf (fl, "    %s *sdb_src = (%s *)src;\n", 
				table->src_t, table->src_t);
    fprintf (fl, "    %s *sdb = (%s *)dest;\n\n", 
				table->sdb_t, table->sdb_t);

    smi = table->smi;
    for (i = 0; i < smi->n_fields; i++) {
	char *name, *type;
	int k;

	name = (char *)smi + smi->fields[i].name_off;
	type = (char *)smi + smi->fields[i].type_off;
	if (strcmp (name, "msg_id") == 0) {
	    fprintf (fl, "    sdb->msg_id = msgid;\n");
	    continue;
	}
	for (k = 0; k < table->n_dis; k++) {	/* user defined input code? */
	    if (strcmp (name, table->dis[k].field_name) == 0) {
		if (strcmp (type, "char *") == 0) {
		    if (table->dis[k].size != NULL) {
			fprintf (fl, "    sdb->%s = malloc (%s);\n", 
						name, table->dis[k].size);
			fprintf (fl, 
			    "    if (sdb->%s == NULL) return (-1);\n", name);
		    }
		    fprintf (fl, "    %s\n", table->dis[k].expression);
		}
		else
		    fprintf (fl, "    %s\n", table->dis[k].expression);
		break;
	    }
	}
	if (k < table->n_dis)		/* found in data_input section */
	    continue;

	/* default - name to name assignment */
	if (strcmp (type, "char *") == 0) {
	    fprintf (fl, "    sdb->%s = malloc (strlen (sdb_src->%s) + 1);\n", 
					name, name);
	    fprintf (fl, "    if (sdb->%s == NULL) return (-1);\n", 
					name);
	    fprintf (fl, "    strcpy (sdb->%s, sdb_src->%s);\n", name, name);
	}
	else
	    fprintf (fl, "    sdb->%s = sdb_src->%s;\n", name, name);
    }

    fprintf (fl, "    return (0);\n");
    fprintf (fl, "}\n");
}

/******************************************************************

    Read the SMI data created by smipp.

******************************************************************/

static void Read_smipp_data (char *name) {
    int fd, i;

    fd = open (name, O_RDONLY);
    if (fd < 0) {
	LE_send_msg (GL_ERROR, "opening SMI data file (%s) failed\n", name);
	exit (1);
    }

    for (i = 0; i < N_tables; i++) {
	if ((Tables[i].smi = (SMI_data_info_t *)
			Read_smi_file (Tables[i].sdb_t, fd)) == NULL) {
	    LE_send_msg (GL_ERROR, 
			"SMI data for %s not found\n", Tables[i].sdb_t);
	    exit (1);
	}
	Verify_sdb_struct (Tables + i, fd);
    }
    close (fd);
}

/******************************************************************

    Read the SMI data file to get SMI for type "type". Returns SMI
    on success or NULL on failure.

******************************************************************/

static char *Read_smi_file (char *type, int fd) {
    char *buf;

    lseek (fd, 0, SEEK_SET);
    buf = NULL;
    while (1) {
	SMI_data_info_t *info, hd;
	int ret;

	ret = read (fd, (char *)&hd, sizeof (SMI_data_info_t));
	if (ret == 0)
	    break;
	if (ret != sizeof (SMI_data_info_t) ||
	    hd.size < sizeof (SMI_data_info_t)) {
	    LE_send_msg (GL_ERROR, "reading SMI data header failed\n");
	    break;
	}
	if (buf != NULL)
	    free (buf);
	buf = SDQSM_malloc (hd.size + 1);
	memcpy (buf, (char *)&hd, sizeof (SMI_data_info_t));
	if (read (fd, buf + sizeof (SMI_data_info_t), 
			hd.size - sizeof (SMI_data_info_t)) != 
					hd.size - sizeof (SMI_data_info_t)) {
	    LE_send_msg (GL_ERROR, "SMI data too short\n");
	    return (NULL);
	}

	info = (SMI_data_info_t *)buf;
	if (strcmp (type, ((char *)info + info->name_off)) == 0)
	    return (buf);
    }
    if (buf != NULL)
	free (buf);
    return (NULL);
}

/******************************************************************

    Verifies the query fields. This also generates table->types 
    and table->qfs (if non-existing) fields.

******************************************************************/

static void Verify_sdb_struct (table_t *table, int fd) {
    SMI_data_info_t *smi;
    int type_size, i, k;
    char *cpt, *name, *type, *typep;

    if (table->rt.src_msg_size == 0) {		/* set src_msg_size */
	smi = (SMI_data_info_t *)Read_smi_file (table->src_t, fd);
	if (smi == NULL) {
	    LE_send_msg (GL_ERROR, 
			"SMI data for %s not found\n", table->src_t);
	    exit (1);
	}
	for (i = 0; i < smi->n_fields; i++) {
	    type = (char *)smi + smi->fields[i].type_off;
	    if (strstr (type, "*") != NULL)
		break;
	}
	if (i >= smi->n_fields)		/* all fields are fixed-size */
	    table->rt.src_msg_size = -1;	/* to be set later */
    }

    smi = table->smi;
    if (table->n_qfs == 0) {		/* all fields are querable */
	int size = 0;
	for (i = 0; i < smi->n_fields; i++) {
	    name = (char *)smi + smi->fields[i].name_off;
	    size += strlen (name) + 1;
	}
	cpt = SDQSM_malloc (size);
	table->qfs = cpt;
	for (i = 0; i < smi->n_fields; i++) {
	    name = (char *)smi + smi->fields[i].name_off;
	    strcpy (cpt, name);
	    cpt += strlen (name) + 1;
	}
	table->n_qfs = smi->n_fields;
    }

    type_size = 0;
    for (i = 0; i < smi->n_fields; i++) {
	type = (char *)smi + smi->fields[i].type_off;
	type_size += strlen (type) + 1;
    }
    table->types = SDQSM_malloc (type_size);
    typep = table->types;
    cpt = table->qfs;
    for (k = 0; k < table->n_qfs; k++) {

	for (i = 0; i < smi->n_fields; i++) {
	    name = (char *)smi + smi->fields[i].name_off;
	    if (strcmp (cpt, name) == 0)
		break;
	}
	if (i >= smi->n_fields)	{
	    LE_send_msg (GL_ERROR, 
		    "bad query field (%s) in table %s\n", cpt, table->name);
	    exit (1);
	}
	if (smi->fields[i].n_items == 0) {	/* implementation limitation */
	    LE_send_msg (GL_ERROR, 
			"array size is not found in field %s in %s\n",
						name, table->sdb_t);
	    exit (1);
	}
	if (smi->fields[i].n_items != 1) {
	    LE_send_msg (GL_ERROR, 
			"array is not supported in field %s in %s\n",
						name, table->sdb_t);
	    exit (1);
	}

	type = (char *)smi + smi->fields[i].type_off;
	if (strcmp (type, "char *") != 0 &&
	    strcmp (type, "float") != 0 &&
	    strcmp (type, "int") != 0 &&
	    strcmp (type, "unsigned int") != 0 &&
	    strcmp (type, "long") != 0 &&
	    strcmp (type, "long int") != 0 &&
	    strcmp (type, "unsigned long") != 0 &&
	    strcmp (type, "short") != 0) {
	    LE_send_msg (GL_ERROR, 
			"type %s is not supported in field %s, table %s\n",
						type, name, table->name);
	    exit (1);
	}
	if (strcmp (type, "long int") == 0)
	    strcpy (type, "int");
	strcpy (typep, type);
	typep += strlen (type) + 1;

	cpt += strlen (cpt) + 1;
    }

    /* make sure all field names in the index tree are fine */
    for (i = 0; i < table->n_its; i++) {
	int m;
	cpt = table->its[i].fields;
	for (m = 0; m < table->its[i].n_fields; m++) {
	    if (!Is_a_valid_field (cpt, smi)) {
		LE_send_msg (GL_ERROR, 
			"bad index field (%s) in table %s\n",
					cpt, table->name);
		exit (1);
	    }
	    cpt += strlen (cpt) + 1;
	}
    }    
}

/******************************************************************

    Verifies if "field_name" is valid sdb field name.

******************************************************************/

static int Is_a_valid_field (char *field_name, SMI_data_info_t *smi) {
    int i;

    for (i = 0; i < smi->n_fields; i++) {
	char *name;
	name = (char *)smi + smi->fields[i].name_off;
	if (strcmp (name, field_name) == 0)
	    return (1);
    }
    return (0);
}

/******************************************************************

    Creates the smipp source file for invoking smipp.

******************************************************************/

static void Create_tm_file (char *name) {
    FILE *fl;
    char *incs;
    int i;

    fl = fopen (name, "w");
    if (fl == NULL) {
	LE_send_msg (GL_ERROR, "creating file (%s) failed\n", name);
	exit (1);
    }

    fprintf (fl, "#include <smi.h>\n");
/*    fprintf (fl, "#include <sdqs.h>\n"); */
    incs = Envs.incs;
    for (i = 0; i < Envs.n_incs; i++) {
	if (strlen (incs) > 1 && strcmp (incs + strlen (incs) - 2, ".c") != 0)
	    fprintf (fl, "#include <%s>\n", incs);
	incs += strlen (incs) + 1;
    }
    fprintf (fl, "\n");

    fprintf (fl, "/%c\n", '*');
    for (i = 0; i < N_tables; i++) {
	fprintf (fl, "SMI_struct %s;\n", Tables[i].sdb_t);
	fprintf (fl, "SMI_struct %s;\n", Tables[i].src_t);
    }
    fprintf (fl, "SMI_function %s;\n", SDQSM_get_smi_func_name ());
    fprintf (fl, "%c/\n", '*');

    fclose (fl);
}

/******************************************************************

    Reads the sdqs configuration file.

******************************************************************/

void SDQSC_read_conf_file (char *conf_name) {
    char *line, *env_name;
    char tmp[TMP_BUF_SIZE], tmp1[TMP_BUF_SIZE + 64];
    int ret, cnt;

    LE_send_msg (LE_VL1, "Reading sdqs configuration file (%s)", conf_name);
    CS_cfg_name (conf_name);
    CS_control (CS_COMMENT | '#');

    CS_control (CS_KEY_OPTIONAL);

    /* read port number */
    if (CS_entry ("SDQS_port", 1, TMP_BUF_SIZE, tmp) > 0) {
	char *port;
	port = SDQSM_malloc (strlen (tmp) + 1); 
	strcpy (port, tmp);
	Add_macro (port);
	SDQSM_set_port_number (port);
    }

    /* read environment section */
    env_name = SDQSM_get_environ_name ();
    if (strlen (env_name) >= TMP_BUF_SIZE) {
	LE_send_msg (GL_ERROR, "Environment name is too long");
	exit (1);
    }
    if (strlen (env_name) == 0)
	strcpy (tmp1, "SDQS_ENV");
    else
	sprintf (tmp1, "%s.%s", "SDQS_ENV", env_name);
    if (CS_entry (tmp1, 0, TMP_BUF_SIZE, tmp) <= 0 ||
	CS_level (CS_DOWN_LEVEL) < 0) {
	if (env_name != NULL)
	    LE_send_msg (LE_VL1, "    Empty SDQS_ENV section %s", tmp1);

	Envs.n_incs = 0;
	Envs.compiler = "gcc";
	Envs.compile_options = Get_default_compile_options (Envs.compiler);
	Envs.smipp_options = "";
	Envs.work_dir = ".";
    }
    else {
	Envs.n_incs = 0;
	if (CS_entry ("include_files", CS_FULL_LINE, TMP_BUF_SIZE, tmp) > 0) {
	    char *cpt, *buf;
	    int tk, len;
    
	    buf = SDQSM_malloc (strlen (tmp) + 1);
	    tk = 0;
	    cpt = buf;
	    Envs.incs = cpt;
	    while ((len = CS_entry (CS_THIS_LINE, 
				tk + 1, TMP_BUF_SIZE, tmp)) > 0) {
		strcpy (cpt, tmp);
		cpt += strlen (cpt) + 1;
		tk++;
	    }
	    Envs.n_incs = tk;
	}

	Envs.compiler = "gcc";
	if (CS_entry ("compiler", 1, TMP_BUF_SIZE, tmp) > 0) {
	    Envs.compiler = SDQSM_malloc (strlen (tmp) + 1); 
	    strcpy (Envs.compiler, tmp);
	}
	if (CS_entry ("compile_options", 1, TMP_BUF_SIZE, tmp) > 0) {
	    Envs.compile_options = SDQSM_malloc (strlen (tmp) + 1); 
	    strcpy (Envs.compile_options, tmp);
	}
	else
	    Envs.compile_options = Get_default_compile_options (Envs.compiler);
	Envs.smipp_options = SDQSM_malloc (1);
	strcpy (Envs.smipp_options, "");
	if (CS_entry ("smipp_options", 1, TMP_BUF_SIZE, tmp) > 0) {
	    Envs.smipp_options = SDQSM_malloc (strlen (tmp) + 1); 
	    strcpy (Envs.smipp_options, tmp);
	}
	if (CS_entry ("include_options", 1, TMP_BUF_SIZE, tmp) > 0) {
	    Envs.compile_options = Append_string (Envs.compile_options, tmp);
	    Envs.smipp_options = Append_string (Envs.smipp_options, tmp);
	}
	if (CS_entry ("lib_options", 1, TMP_BUF_SIZE, tmp) > 0)
	    Envs.compile_options = Append_string (Envs.compile_options, tmp);
	if (CS_entry ("libsdqs_location", 1, TMP_BUF_SIZE, tmp) <= 0)
	    strcpy (tmp, "./");
	sprintf (tmp1, "-o %s/%s", tmp, SDQSM_get_shared_lib_name ());
	Envs.compile_options = Append_string (Envs.compile_options, tmp1);
	LE_send_msg (GL_INFO, "shared library: %s/%s\n", 
				tmp, SDQSM_get_shared_lib_name ());

	Envs.work_dir = ".";
	if (CS_entry ("work_dir", 1, TMP_BUF_SIZE, tmp) > 0) {
	    Envs.work_dir = SDQSM_malloc (strlen (tmp) + 1); 
	    strcpy (Envs.work_dir, tmp);
	}
    }

    /* read SDB table */
    CS_level (CS_TOP_LEVEL);
    line = CS_THIS_LINE;
    cnt = 0;
    while (1) {			/* find how many tables */
	ret = CS_entry (line, 0, TMP_BUF_SIZE, tmp);
	if (ret <= 0)
	    break;
	cnt++;
	line = CS_NEXT_LINE;
    }

    Tables = (table_t *)SDQSM_malloc (sizeof (table_t) * cnt);

    N_tables = 0;
    CS_level (CS_TOP_LEVEL);
    line = CS_THIS_LINE;
    while (1) {
	table_t *tbl;
	int data_size;

	ret = CS_entry (line, 0, TMP_BUF_SIZE, tmp);
	if (ret <= 0)
	    break;
	if (strncmp (tmp, "SDQS_ENV", 8) == 0 ||
	    strcmp (tmp, "SDQS_port") == 0 ||
	    CS_level (CS_DOWN_LEVEL) < 0) {
	    line = CS_NEXT_LINE;
	    continue;
	}

	tbl = Tables + N_tables;
	tbl->name = SDQSM_malloc (strlen (tmp) + 1);
	strcpy (tbl->name, tmp);

	tbl->src_t = "";
	tbl->data_input_func = "";
	tbl->house_keep_func = "";
	if (CS_entry ("house_keep_func", 1, TMP_BUF_SIZE, tmp) > 0) {
	    tbl->house_keep_func = SDQSM_malloc (strlen (tmp) + 1);
	    strcpy (tbl->house_keep_func, tmp);
	}
	if (CS_entry ("data_input_func", 1, TMP_BUF_SIZE, tmp) > 0) {
	    tbl->data_input_func = SDQSM_malloc (strlen (tmp) + 1);
	    strcpy (tbl->data_input_func, tmp);
	}
	tbl->rt.src_msg_size = 0;
	if (CS_entry ("src_data_size", 1 | CS_INT, 0, (char *)&data_size) > 0)
	    tbl->rt.src_msg_size = data_size;

	CS_control (CS_KEY_REQUIRED);
	tmp1[0] = '\0';
	if (CS_entry ("src_struct", 1, TMP_BUF_SIZE, tmp) <= 0 ||
		(strcmp (tmp, "struct") == 0 &&
		 CS_entry ("src_struct", 2, TMP_BUF_SIZE, tmp1) <= 0)) {
	    LE_send_msg (GL_ERROR, 
			"src_struct not found in table %s\n", tbl->name);
	    exit (1);
	}
	tbl->src_t = SDQSM_malloc (strlen (tmp) + strlen (tmp1) + 1);
	strcpy (tbl->src_t, tmp);
	if (tmp1[0] != '\0')
	    sprintf (tbl->src_t + strlen (tmp), " %s", tmp1);

	tmp1[0] = '\0';
	if (CS_entry ("sdb_struct", 1, TMP_BUF_SIZE, tmp) <= 0 ||
		(strcmp (tmp, "struct") == 0 &&
		 CS_entry ("sdb_struct", 2, TMP_BUF_SIZE, tmp1) <= 0)) {
	    LE_send_msg (GL_ERROR, 
			"sdb_struct not found in table %s\n", tbl->name);
	    exit (1);
	}
	tbl->sdb_t = SDQSM_malloc (strlen (tmp) + strlen (tmp1) + 1);
	strcpy (tbl->sdb_t, tmp);
	if (tmp1[0] != '\0')
	    sprintf (tbl->sdb_t + strlen (tmp), " %s", tmp1);

	CS_control (CS_KEY_OPTIONAL);
	if (CS_entry ("src_lb", 1, TMP_BUF_SIZE, tmp) > 0) {
	    tbl->src_lb = SDQSM_malloc (strlen (tmp) + 1);
	    strcpy (tbl->src_lb, tmp);
	}
	else if (CS_entry ("src_data_store", 1, TMP_BUF_SIZE, tmp) > 0) {
	    tbl->src_lb = SDQSM_malloc (strlen (tmp) + 1);
	    strcpy (tbl->src_lb, tmp);
	    Add_macro (tbl->src_lb);
	}
	else {
	    LE_send_msg (GL_ERROR, 
	    "sourse LB (src_lb or src_data_store) not found in table %s\n", 
							tbl->name);
	    exit (1);
	}

	if (CS_entry ("data_input", 0, TMP_BUF_SIZE, tmp) > 0 &&
	    CS_level (CS_DOWN_LEVEL) >= 0) {
	    tbl->n_dis = Read_data_input (&(tbl->dis));
	    CS_level (CS_UP_LEVEL);
	}
	if (CS_entry ("index_trees", 0, TMP_BUF_SIZE, tmp) > 0 &&
	    CS_level (CS_DOWN_LEVEL) >= 0) {
	    tbl->n_its = Read_index_tree (&(tbl->its));
	    CS_level (CS_UP_LEVEL);
	}

	tbl->n_qfs = 0;
	if (CS_entry ("query_fields", CS_FULL_LINE, TMP_BUF_SIZE, tmp) > 0) {
	    char *cpt, *buf;
	    int tk, len;
    
	    buf = SDQSM_malloc (strlen (tmp) + 1);
	    tk = 0;
	    cpt = buf;
	    tbl->qfs = cpt;
	    while ((len = CS_entry (CS_THIS_LINE, 
				tk + 1, TMP_BUF_SIZE, tmp)) > 0) {
		strcpy (cpt, tmp);
		cpt += strlen (cpt) + 1;
		tk++;
	    }
	    tbl->n_qfs = tk;
	}
	tbl->no_msg_exp_proc = 0;
	if (CS_entry ("no_message_expire_processing", 
						0, TMP_BUF_SIZE, tmp) > 0)
	    tbl->no_msg_exp_proc = 1;
	tbl->data_endian = SDQS_SERIAL;
	if (CS_entry ("data_endian", 0, TMP_BUF_SIZE, tmp) > 0) {
	    if (CS_entry ("data_endian", 1, TMP_BUF_SIZE, tmp) > 0) {
		if (strcmp (tmp, "big") == 0)
		    tbl->data_endian = SDQS_BIG_ENDIAN;
		else if (strcmp (tmp, "little") == 0)
		    tbl->data_endian = SDQS_LITTLE_ENDIAN;
		if (strcmp (tmp, "big") == 0)
		    tbl->data_endian = SDQS_BIG_ENDIAN;
		else if (strcmp (tmp, "local") == 0)
		    tbl->data_endian = SDQS_LOCAL_ENDIAN;
	    }
	    if (tbl->data_endian == SDQS_SERIAL) {
		LE_send_msg (GL_ERROR, 
		    "Unexpected data_endian spec in table %s\n", tbl->name);
		exit (1);
	    }
	}

	N_tables++;
	line = CS_NEXT_LINE;
	CS_level (CS_UP_LEVEL);
    }

    if (Verbose)
	Print_config_info ();
    CS_cfg_name ("");
    if (N_tables == 0) {
	LE_send_msg (GL_ERROR, "No table found in %s\n", conf_name);
	exit (1);
    }
}

/**************************************************************************

    Reads data_input section. Returns the list of fields in "dis". The
    return value is the number of fields found.

**************************************************************************/

static int Read_data_input (data_input_t **dis) {
    data_input_t *di, *d;
    int cnt, n;
    char *line, tmp[TMP_BUF_SIZE];

    line = CS_THIS_LINE;
    cnt = 0;
    while (1) {			/* find how many items */
	if (CS_entry (line, 0, TMP_BUF_SIZE, tmp) <= 0)
	    break;
	cnt++;
	line = CS_NEXT_LINE;
    }
    di = (data_input_t *)SDQSM_malloc (sizeof (data_input_t) * cnt);
    *dis = di;

    CS_level (CS_UP_LEVEL);
    CS_level (CS_DOWN_LEVEL);
    line = CS_THIS_LINE;
    n = 0;
    while (n < cnt) {
	char *cpt;
	int st, end;

	d = di + n;
	if (CS_entry (line, 0, TMP_BUF_SIZE, tmp) <= 1 ||
	    *(tmp + strlen (tmp) - 1) != ':') {
	    LE_send_msg (GL_ERROR, "bad field name (%s)\n", tmp);
	    exit (1);
	}
	d->field_name = SDQSM_malloc (strlen (tmp) + 1);
	strcpy (d->field_name, tmp);
	d->field_name[strlen (tmp) - 1] = '\0';	/* remove ':' */
	
	CS_entry (CS_THIS_LINE, CS_FULL_LINE, TMP_BUF_SIZE, tmp);
	/* look for size - we don't do syntax error checking */
	cpt = tmp;
	st = end = -1;
	while (*cpt != '\0') {
	    if (*cpt == '[') {
		if (st < 0)
		    st = cpt - tmp + 1;
	    }
	    if (*cpt == ']') {
		end = cpt - tmp - 1;
		break;
	    }
	    cpt++;
	}
	d->size = NULL;
	if (st >= 0 && end >= 0 && end >= st) {
	    d->size = SDQSM_malloc (end - st + 2);
	    strncpy (d->size, tmp + st, end - st + 1);
	    d->size[end - st + 1] = '\0';
	}

	/* get expression */
	if (end < 0)
	    cpt = tmp + strlen (d->field_name) + 1;
	else
	    cpt = tmp + end + 2;
	while (*cpt != '\0' && Is_separator (*cpt))
	    cpt++;
	if (strlen (cpt) == 0) {
	    LE_send_msg (GL_ERROR, 
			"expression missing for field %s\n", d->field_name);
	    exit (1);
	}
	d->expression = SDQSM_malloc (strlen (cpt) + 1);
	strcpy (d->expression, cpt);

	n++;
	line = CS_NEXT_LINE;
    }
    return (n);
}

/**************************************************************************

    Reads index_trees section. Returns the list of trees in "its". The
    return value is the number of trees found.

**************************************************************************/

static int Read_index_tree (index_tree_t **its) {
    index_tree_t *it, *t;
    int cnt, n;
    char *line, tmp[TMP_BUF_SIZE];

    line = CS_THIS_LINE;
    cnt = 0;
    while (1) {			/* find how many lines */
	if (CS_entry (line, 0, TMP_BUF_SIZE, tmp) <= 0)
	    break;
	cnt++;
	line = CS_NEXT_LINE;
    }
    it = (index_tree_t *)SDQSM_malloc (sizeof (index_tree_t) * cnt);
    *its = it;

    CS_level (CS_UP_LEVEL);
    CS_level (CS_DOWN_LEVEL);
    line = CS_THIS_LINE;
    n = 0;
    while (n < cnt) {
	char *cpt, *buf;
	int tk, len;

	t = it + n;
	CS_entry (line, CS_FULL_LINE, TMP_BUF_SIZE, tmp);
	buf = SDQSM_malloc (strlen (tmp) + 1);

	tk = 0;
	cpt = buf;
	t->fields = cpt;
	while ((len = CS_entry (CS_THIS_LINE, tk, TMP_BUF_SIZE, tmp)) > 0) {
	    strcpy (cpt, tmp);
	    cpt += strlen (cpt) + 1;
	    tk++;
	}
	t->n_fields = tk;
	n++;
	line = CS_NEXT_LINE;
    }
    return (n);
}

/**************************************************************************

    Adds a macro "name" to the macro list. We may add sheck later to 
    remove duplicated names.

**************************************************************************/

static void Add_macro (char *name) {
    macro_list_t *m;
    int t;

    if (sscanf (name, "%d", &t) == 1)	/* assume not a macro */
	return;

    m = (macro_list_t *)SDQSM_malloc (sizeof (macro_list_t));
    m->macro = name;
    m->next = NULL;
    if (Macros == NULL)
	Macros = m;
    else {
	macro_list_t *t;
	t = Macros;
	while (t->next != NULL)
	    t = t->next;
	t->next = m;
    }
}

/**************************************************************************

    Returns non-zero if "c" is a separation character. Zero otherwise.

**************************************************************************/

static int Is_separator (char c) {
    if (c == ' ' || c == '\n' || c == '\t')
	return (1);
    return (0);
}

/******************************************************************

    Prints contents in sdqs conf file for debugging. This also 
    provides a template on how to use the table_t structure.

******************************************************************/

static void Print_config_info () {
    char *incs;
    int i, k, m;

    incs = Envs.incs;
    for (i = 0; i < Envs.n_incs; i++) {
	printf ("include: %s-\n", incs);
	incs += strlen (incs) + 1;
    }

    printf ("\ncompiler %s-\n", Envs.compiler);
    printf ("smipp_options %s-\n", Envs.smipp_options);
    printf ("compile_options %s-\n", Envs.compile_options);
    printf ("work_dir %s-\n", Envs.work_dir);

    printf ("\n%d tables:\n", N_tables);
    for (i = 0; i < N_tables; i++) {
	data_input_t *dis;
	index_tree_t *its;
	char *cpt;

	printf ("\n    name %s-\n", Tables[i].name);
	printf ("    src_t %s-\n", Tables[i].src_t);
	printf ("    sdb_t %s-\n", Tables[i].sdb_t);
	printf ("    src_lb %s-\n", Tables[i].src_lb);
	printf ("    data_input_func %s-\n", Tables[i].data_input_func);
	printf ("    house_keep_func %s-\n", Tables[i].house_keep_func);

	printf ("    n_dis %d:\n", Tables[i].n_dis);
	dis = Tables[i].dis;
	for (k = 0; k < Tables[i].n_dis; k++) {
	    printf ("\n	field_name %s\n", dis[k].field_name);
	    if (dis[k].size != NULL)
		printf ("	size %s\n", dis[k].size);
	    printf ("	expression %s\n", dis[k].expression);
	}

	printf ("\n    n_qfs %d: ", Tables[i].n_qfs);
	cpt = Tables[i].qfs;
	for (k = 0; k < Tables[i].n_qfs; k++) {
	    printf ("%s ", cpt);
	    cpt += strlen (cpt) + 1;
	}
	printf ("-\n");

	printf ("    n_its %d\n", Tables[i].n_its);
	its = Tables[i].its;
	for (k = 0; k < Tables[i].n_its; k++) {
	    printf ("	n_fields %d: ", its[k].n_fields);
	    cpt = its[k].fields;
	    for (m = 0; m < its[k].n_fields; m++) {
		printf ("	%s", cpt);
		cpt += strlen (cpt) + 1;
	    }
	    if (Tables[i].n_its > 0)
		printf ("-\n");
	}
    }
}

/******************************************************************

    Appends a space and "str2" to "str1" and then frees "str1".
    Returns the appended string.

******************************************************************/

static char *Append_string (char *str1, char *str2) {
    char *p;

    p = SDQSM_malloc (strlen (str1) + strlen (str2) + 2);
    sprintf (p, "%s %s", str1, str2);
    free (str1);
    return (p);
}

/******************************************************************

    Returns compiler options for building synamically loadable file.

******************************************************************/

static char *Get_default_compile_options (char *compiler) {
    char *opt, *p;

/*
    if (strcmp (compiler, "gcc") == 0)
	opt = "-nostartfiles -Xlinker -G -fpic -Wall";
*/
    if (strcmp (compiler, "gcc") == 0)
	opt = "-shared -fpic -Wall";
    else if (strcmp (compiler, "c89") == 0 ||
		strcmp (compiler, "cc") == 0)
	opt = "-Kpic -G";
    else
	opt = "";
    p = SDQSM_malloc (strlen (opt) + 1);
    strcpy (p, opt);
    return (p);
}

/******************************************************************

    Returns a string contains all SDB table names.

******************************************************************/

static char *Get_all_table_names () {
    int i;

    for (i = 0; i < N_tables; i++)
	Archive_string (Tables[i].name);
    return (Archive_string ((char *)1));
}

/******************************************************************

    Returns a string contains all necessary info for running sdqs
    without reading the config file.

******************************************************************/

static char *Get_config_str (table_t *table) {
    int k, m;
    index_tree_t *its;
    char *cpt, tmp[32];

    Archive_string (table->src_t);
    Archive_string (table->sdb_t);
    Archive_string (table->src_lb);
    Archive_string (table->house_keep_func);

    sprintf (tmp, "%d", table->n_its);
    Archive_string (tmp);
    its = table->its;
    for (k = 0; k < table->n_its; k++) {
	sprintf (tmp, "%d", its[k].n_fields);
	Archive_string (tmp);
	cpt = its[k].fields;
	for (m = 0; m < its[k].n_fields; m++) {
	    Archive_string (cpt);
	    cpt += strlen (cpt) + 1;
	}
    }
    sprintf (tmp, "%d", table->no_msg_exp_proc);
    Archive_string (tmp);
    sprintf (tmp, "%d", table->data_endian);
    Archive_string (tmp);
    sprintf (tmp, "%d", table->rt.src_msg_size);
    Archive_string (tmp);
    return (Archive_string ((char *)1));
}

/******************************************************************

    Adds string "str" to the Archive. Returns the pointer to
    the archive. If "str" is 1, terminates the string and the
    archive (a new archive will start next time this is called).

******************************************************************/

static char *Archive_string (char *str) {
    static char *buf = NULL;
    static int n_bytes = 0, buf_size = 0;
    int size;
    char *p;

    if ((int)str == 1) {
	if (buf != NULL)
	    buf[strlen (buf) - 1] = '\0';
	n_bytes = 0;
	return (buf);
    }

    if (str == NULL || str[0] == '\0')
	p = "NULL";
    else
	p = str;
    size = strlen (p) + 1;
    if (size + n_bytes >= buf_size) {
	char *tmp;
	tmp = SDQSM_malloc (size + n_bytes + 1024);
	memcpy (tmp, buf, n_bytes);
	if (buf != NULL)
	    free (buf);
	buf = tmp;
	buf_size = size + n_bytes + 1024;
    }
    strcpy (buf + n_bytes, p);
    n_bytes += size;
    strcpy (buf + n_bytes - 1, " ");
    return (buf);
}

/******************************************************************

    Returns function name for table "table".

******************************************************************/

char *SDQSC_get_func_name (int which, table_t *table) {
    static char buf[128];

    if (strlen (table->name) + 64 > 128) {
	LE_send_msg (GL_ERROR, "table name (%s) too long", table->name);
	exit (1);
    }
    switch (which) {
	case GET_RECORD_FUNC:
	    strcpy (buf, "SDQSD_get_record");
	    break;
	case BYTE_SWAP_FUNC:
	    strcpy (buf, "SDQSD_byte_swap");
	    break;
	case GET_MISC_FUNC:
	    strcpy (buf, "SDQSD_get_misc");
	    break;
	case FREE_RECORD_FUNC:
	    strcpy (buf, "SDQSD_free_record");
	    break;
	default :
	    strcpy (buf, "");
	    break;
    }
    sprintf (buf + strlen (buf), "_%s", table->name);
    return (buf);
}


